---
title: "Impact with base model for new classification"
author: "Willem Goossens"
date: "`r Sys.Date()`"
output: html_document
---

# 1 START

## 1.1 General
```{r, echo=FALSE}
rm(list=ls())
gc()
```


Load packages
```{r, warnings=F, message=F}
library(readr)
library(dplyr)
library(mgcv)
library(modEvA)
library(ggplot2)
library(doParallel)
library(foreach)
#library(tidyverse)
library(geometry)
library(factoextra)
library(ggpubr)
#library(rstatix)
#library(rcompanion)
library(ggeffects)
library(emmeans)
library(lmerTest)

```


Here we set some parameters that are useful in the script
```{r}
correctArea<- F
```


## 1.2 Data
Load eva and plot data
```{r, warnings=F, message=F}
eva <- read_csv("fullPlotEva_ESy.csv")
fullPlotData <- read_csv("fullPlotData_EUNIS.csv")

# habitat choice
habitats <- unique(fullPlotData$habitat)
# adapt here the type you want to assess, e.g. 'grasslands'=1
chose_eunis =F
if(chose_eunis){
  fullPlotData <- fullPlotData[fullPlotData$habitat==habitats[3] & !is.na(fullPlotData$habitat),]
  eva <- eva[eva$PlotObservationID %in% fullPlotData$PlotObservationID,]
}
```


Downsample by a factor of 100 if fast is selected
```{r}
fast <- T
fullPlotData$Date <- as.Date(fullPlotData$Date, format = c("%Y-%m-%d"))
fullPlotData <- fullPlotData[fullPlotData$Date > "1980-01-01",]
if(fast) {
  fullPlotData <- fullPlotData[runif(length(fullPlotData$PlotObservationID)) > 0.999,]
  eva <- eva[eva$PlotObservationID %in% fullPlotData$PlotObservationID,]
}


# data for co-authors (make sure same dataset)
#eva<- read.csv("downsampledEva.csv", header=T)
#colnames(eva)[8]<- "Cover %"
#fullPlotData<- read.csv("downsampledPlotData.csv")
```


## 1.3 Neophyte
Load the neophyte definitions:
```{r, message=F}
# Data on which species are neophytes
native_intra_analysis=F
if(native_intra_analysis){
  species_country_status<- read_csv("country_species_ESy.csv", show_col_types = FALSE)
} else{
  species_country_status<- read_csv("country_species_ESy.csv", show_col_types = FALSE)
  species_country_status$Neophyte[species_country_status$Neophyte=="native_intra"] <- "native"
}

# Assign these names to the eva list
extra_EU <- unique(species_country_status$species[species_country_status$Neophyte=="extra"])
intra_EU <- unique(species_country_status$species[species_country_status$Neophyte=="intra"])
if(native_intra_analysis){
native_intra <- unique(species_country_status$species[species_country_status$Neophyte=="native_intra"])
}
```



Assign classification to species
```{r}
# Only observation ID and Region
fullPlot2<- fullPlotData[,c("PlotObservationID","Region")]
# Right join to keep only species present in fullplot (otherwise a lot of NAs)
eva<- right_join(eva, fullPlot2, by = c("PlotObservationID"="PlotObservationID"))
# Join eva and classification
eva<- left_join(eva, species_country_status[, -c(2:4,6:8)], by= c("Region"= "Region", "name"= "name"))
# Look at how much from every type are present
table(eva$Neophyte)
```




## 1.4 Number of plots
Reduce EVA to a smaller dataset to accelerate computations.    
Count the number of plots in which the species in the dataset exist.  
```{r, message=F}
fast=T
if(fast) {
  # downsize dataset
  reducedEva <- eva |> select(PlotObservationID, name, `Cover %`, 
                              Neophyte, Layer)
  
  # calculate sum of cover per species in a layer
  reducedEva <- reducedEva |> group_by(PlotObservationID, name, Neophyte, Layer) |> summarise(cover= sum(`Cover %`))

  # if species is present across multiple layers use fisher's method
  reducedEva <- reducedEva|> group_by(PlotObservationID, name, Neophyte) |> 
    summarise(cover = (1-prod((1-ifelse(cover/100>1, 1, cover/100 ))))*100)

  # add total cover to fullPlotData
  fullPlotData <- reducedEva %>% group_by(PlotObservationID) %>% summarise(totalCover = sum(cover)) %>%
    left_join(fullPlotData, by = "PlotObservationID")
  
  # Copy the full dataset without aberrant totalCover
  fullPlotData <- fullPlotData %>% filter(totalCover <= 900)
  reducedEva <- reducedEva[reducedEva$PlotObservationID %in% fullPlotData$PlotObservationID,]
  eva <- eva[eva$PlotObservationID %in% fullPlotData$PlotObservationID,]
  
  # get list unique species
  uniqueSpecies <- unique(reducedEva[, c(2,3)])
  
  # Empty dataset

  # Prepare parallel
  parallel::detectCores()
  n.cores <- parallel::detectCores() - 2
  my.cluster <- parallel::makeCluster(n.cores, type = "PSOCK")
  print(my.cluster)
  doParallel::registerDoParallel(cl = my.cluster)
  foreach::getDoParRegistered()
  foreach::getDoParWorkers()

  plotsPerSpecies <- data.frame(names = character(), 
                                numberOfPlots = integer(), 
                                Neophyte= character())
  
  # Count in how many plots a species occurs
  begin<- Sys.time()
  plotsPerSpecies<-foreach(i= 1:nrow(uniqueSpecies), .combine='rbind',
                         .packages=c("dplyr","mgcv")) %dopar% {
    tmp <- reducedEva$PlotObservationID[reducedEva$name == uniqueSpecies$name[i] &
                                          reducedEva$Neophyte == uniqueSpecies$Neophyte[i]]
    names=uniqueSpecies$name[i]
    numberOfPlots= length(unique(tmp))
    plotsPerSpecies[i,]<- c(names, numberOfPlots,
                            Neophyte=uniqueSpecies$Neophyte[i] )
  }
  
  plotsPerSpecies<- as.data.frame(plotsPerSpecies)
  plotsPerSpecies<-setNames(plotsPerSpecies, c("names", "numberOfPlots","Neophyte"))
  plotsPerSpecies$numberOfPlots <- as.numeric(plotsPerSpecies$numberOfPlots)
  row.names(plotsPerSpecies)<- c(1: nrow(uniqueSpecies))
  
  end<- Sys.time()
  round(end-begin)
  
  parallel::stopCluster(cl = my.cluster)
  #write.csv(plotsPerSpecies, "speciesDominance.csv")
} else {
  if(native_intra_analysis){
  plotsPerSpecies <- read.csv("speciesDominance_native_intra.csv")
  }else{
  plotsPerSpecies<- read.csv("speciesDominance.csv")
  }
}
```


## 1.5 Select
We want all species that are present in at least 30 plots, we order this set from highest to lowest and subsequently make a function to compute the total cover of the species across all sites.
```{r}
# If you want to have a look at the distribution of the species richness per plot: hist(plotsPerSpecies$numberOfPlots[plotsPerSpecies$numberOfPlots>1000])

# determine which plant species should be computed
minimumNumberOfPlots<- 30
allPlants <- plotsPerSpecies[plotsPerSpecies$numberOfPlots >= minimumNumberOfPlots,]
allPlants <- allPlants[order(-allPlants$numberOfPlots),]
rownames(allPlants)<- c(1: nrow(allPlants))
```


## 1.6 Total cover
Compute total cover for each plot.
```{r}
# 
reducedEva <- eva |> select(PlotObservationID, name, `Cover %`, Neophyte, Layer)

reducedEva <- reducedEva |> group_by(PlotObservationID, name, Neophyte, Layer) |> summarise(cover= sum(`Cover %`))

reducedEva_official <- reducedEva|> group_by(PlotObservationID, name, Neophyte) |> 
  summarise(cover = (1-prod((1-ifelse(cover/100>1, 1, cover/100 ))))*100)
```


## 1.7 PCA
```{r}
head(fullPlotData)
# Perform PCA with scaled (i.e. unit variance) variables on all EIVE and DIV variables in base model + chelsa P and hfp (add 54 for elevation)
PCA<- prcomp(fullPlotData[, c(26:31, 33:35, 51,53)  ], scale=T)
  
# get amount of variance explained by top 4 axes
eig.val <- get_eigenvalue(PCA)
eig.val<- eig.val[4,3]
eig.val
  
# get coordinates of first 4 axes and bind to the dataset
PCA<- PCA$x[,1:4]
dim(PCA)
fullPlotData <- cbind(fullPlotData, PCA)
```



# 2 ANALYSIS
## 2.1 Function 
```{r, meassage=F}
# The name of the first species (to test the function)
plantName = allPlants$names[1]
plantStatus= allPlants$Neophyte[1]

# Function to compute the impact for each species, so we only need the plant name as input
computePlantImpact <- function(plantName, plantStatus) {
  
  
  # Copy the full dataset without aberrant totalCover
  tmpFullPlotData <- fullPlotData %>% filter(totalCover <=900)
  reducedEva <- reducedEva_official
  reducedEva <- reducedEva[reducedEva$PlotObservationID %in% tmpFullPlotData$PlotObservationID,]
  
  # Select only explanatory variables
  tmpFullPlotData <- tmpFullPlotData %>% 
    select(PlotObservationID, numberOfVascularPlantSpecies, Area, 
           EIVEresM, EIVEresN, EIVEresR, EIVEresL, EIVEresT, 
           DistSeverity.sqrt, Soil.Disturbance.sqrt, 
           Grazing.Pressure.sqrt, Mowing.Frequency.sqrt, 
           Latitude, Longitude, Dataset, chelsaP, hfp, totalCover, PC1, PC2, PC3,PC4, ENS0, elev)
  
  # Get the indices of the plant in the eva dataset
  indexOfPlant <- reducedEva$name == plantName & reducedEva$Neophyte== plantStatus
  any(indexOfPlant)
  # We select only the rows containing the species first because this is much faster than doing it for all plots.
  # We make the dataset smaller (only those plots where the species is present), group the data per plot and 
  # compute the cover of the species we are highlighting now
  plotsWherePlantOccurs <- reducedEva[indexOfPlant,c(1,4)]
  colnames(plotsWherePlantOccurs)[2]<- "speciesCover"
  
  
  # Join the computed cover plots with the full data
  tmpFullPlotData <- left_join(tmpFullPlotData, plotsWherePlantOccurs, by = "PlotObservationID")
  # Identify all plots where the species investigated occurs
  tmpFullPlotData$plantOccurs = tmpFullPlotData$PlotObservationID %in% reducedEva$PlotObservationID[indexOfPlant]

  # reduce the dataset to obtain only those plots in which the species is present
  species_plots <- tmpFullPlotData[tmpFullPlotData$plantOccurs, c(19:22)]
  # make matrix and reduce duplicated columns
  species_plots<- as.matrix(species_plots)
  duplicated<- duplicated(species_plots)
  species_plots<- species_plots[!duplicated,]
  
  # take ConvexHull around the PCA coordinates in which the species is present
  convex_hull <- convhulln((species_plots))

  # Extract all points from the dataset that are additionally within this ConvexHull and do not contain the species
  is_within_hull <- inhulln(convex_hull, as.matrix(tmpFullPlotData[, c(19:22)]))
  subset_data <- tmpFullPlotData[is_within_hull, ]
  
  # Take size of subset data
  size<- length(subset_data$plantOccurs)
  species_plot_number <- sum(subset_data$plantOccurs)

  
  # check relative size difference datasets
  rel = species_plot_number/size
  
  if(rel< 0.10){
    needed_size <- (species_plot_number/0.10)-species_plot_number
    data_to_sample <- subset_data[!subset_data$plantOccurs,]
    sample <- sample(data_to_sample$PlotObservationID, needed_size, replace=F)
    update <- data_to_sample[data_to_sample$PlotObservationID %in% sample,]
    subset_data <- rbind(subset_data[subset_data$plantOccurs,], update)
    size<- length(subset_data$plantOccurs)
  }
   
  if(rel> 0.30){
    needed_size <- ceiling((species_plot_number/0.30)-size)
    data_to_sample <- tmpFullPlotData[!tmpFullPlotData$PlotObservationID %in% subset_data$PlotObservationID,]
    sample <- sample(data_to_sample$PlotObservationID, needed_size, replace=F)
    update <- data_to_sample[data_to_sample$PlotObservationID %in% sample,]
    subset_data <- rbind(subset_data, update)
    size<- length(subset_data$plantOccurs)
  }  
  
  if(size < 200){
    needed_size <- 200-size
    data_to_sample <- tmpFullPlotData[!tmpFullPlotData$PlotObservationID %in% subset_data$PlotObservationID,]
    sample <- sample(data_to_sample$PlotObservationID, needed_size, replace=F)
    update <- data_to_sample[data_to_sample$PlotObservationID %in% sample,]
    subset_data <- rbind(subset_data, update)
    size<- length(subset_data$plantOccurs)
  }
  
  
     
  # change data 
  tmpFullPlotData <- subset_data

  # If species is not present:
  tmpFullPlotData$speciesCover[is.na(tmpFullPlotData$speciesCover)] <- 0.0
  tmpFullPlotData$totalCover[is.na(tmpFullPlotData$speciesCover)] <- 100.0

  # Exclude all plots which have 0 total cover
  tmpFullPlotData <- tmpFullPlotData[tmpFullPlotData$totalCover >0,] 
  
  # Do SR - 1 for all plots in which the species is present
  tmpFullPlotData$ENS0 <- tmpFullPlotData$ENS0 - tmpFullPlotData$plantOccurs
  
  # Correct area: if true we calculate the area that is reserved for the other plant species. 
  if(correctArea) {
    tmpFullPlotData$Area <- tmpFullPlotData$Area*(1.0 - tmpFullPlotData$speciesCover/tmpFullPlotData$totalCover)
  }
  
  # There is a numerical problem in the bam function if we provide empty plots...
  tmpFullPlotData <- tmpFullPlotData %>% filter(numberOfVascularPlantSpecies > 0, Area > 0)
  
  # Make dataset a factor to add it as a random variable
  tmpFullPlotData$Dataset <- as.factor(tmpFullPlotData$Dataset)

  # Add relative species cover
  tmpFullPlotData <- tmpFullPlotData %>% 
    mutate(relSpeciesCover = 100 * speciesCover / totalCover) |>
    mutate(coverClass = cut(relSpeciesCover,breaks = c(-1, 0, 1, 10, 30, 50, 70, 101), 
                            labels = c("0%", "0%-1%", "1%-10%", "10%-30%", "30%-50%","50%-70%","70%-100%")))
  
  tmpFullPlotData$coverClass<- as.character( tmpFullPlotData$coverClass)
  tmpFullPlotData$coverClass[(tmpFullPlotData$speciesCover==0.0)] <- c("0%")
  
  # Species occurrence as factor (not logical)
  tmpFullPlotData$plantOccursF <- factor(tmpFullPlotData$plantOccurs)
  tmpFullPlotData$coverClass <- factor(tmpFullPlotData$coverClass)
  
  # Base model
  model<-  (ENS0) ~ 
              s(log(Area),bs='tp') + 
              s(EIVEresM, bs = 'tp') +
              s(EIVEresN, bs = 'tp') +
              s(EIVEresR, bs = 'tp') +
              s(EIVEresL, bs = 'tp') +
              s(EIVEresT, bs = 'tp') +
              s(DistSeverity.sqrt, bs = 'tp') +
              s(Soil.Disturbance.sqrt, bs = 'tp')+
              s(Grazing.Pressure.sqrt, bs = 'tp')+
              s(Mowing.Frequency.sqrt, bs = 'tp') +
              s(Latitude, Longitude, bs = 'tp') +
              s(chelsaP, bs='tp')+
              s(hfp, bs='tp')+
              s(Dataset, bs="re")+
              s(elev, bs="tp")+
              coverClass
  
  
  base <- bam(model,family = nb(), data = tmpFullPlotData,  method = 'fREML',  discrete=TRUE, nthreads=4)
  baseModel<- summary(base)
  baseModel
  
  
  # Make a dataframe to add the residuals to
  res <- data.frame(taxa = character(), Estimate = numeric(),
                    StdErr = numeric(),
                    `zValue` = numeric(),
                    pr = numeric(),
                    Intercept= numeric(), 
                    numberOfPlots = integer(), 
                    Neophyte= character(),
                    RelDiff= numeric(),
                    class= character(), n=numeric(),
                    size= numeric(),
                    rel= numeric())
  


  # Helper function to add rows if the index is within bounds
  add_row_if_exists <- function(res,baseModel, idx, class, coverClass, plantName, plantStatus, tmpFullPlotData,
                                plotsWherePlantOccurs,baseModel2) {
      res <- add_row(res, 
                     taxa = plantName, 
                     Estimate = baseModel$p.table[idx, 1],
                     StdErr = baseModel$p.table[idx, 2],
                     zValue = baseModel$p.table[idx, 3], 
                     pr = baseModel$p.table[idx, 4],
                     Intercept = baseModel$p.table[1, 1],  
                     numberOfPlots = length(plotsWherePlantOccurs$PlotObservationID), 
                     Neophyte = plantStatus,
                     RelDiff = 
                       (mean(fitted(base)[tmpFullPlotData$coverClass == coverClass]) -
                        mean(fitted(base)[tmpFullPlotData$coverClass == "0%"])) /
                        mean(fitted(base)[tmpFullPlotData$coverClass == "0%"]),
                     class = class, n = sum(tmpFullPlotData$coverClass == coverClass),
                     size= size, rel= length(plotsWherePlantOccurs$PlotObservationID)/ size)
    return(res)
  }
  
  uniqueFactors  <- sort(unique(tmpFullPlotData$coverClass))
  uniqueFactors
  
  for(i in 2:  nrow(baseModel$p.table)){
      index <- uniqueFactors[i]
      res <- add_row_if_exists(res, baseModel, i, index, index, plantName, plantStatus, tmpFullPlotData,
                             plotsWherePlantOccurs, baseModel2)
  }
  res

}

```



## 2.2 Impact
Use foreach to speed up computations
```{r}
if(fast){

# prepare parallel
n.cores<- parallel::detectCores()-2.
my.cluster <- parallel::makeCluster(n.cores, type = "PSOCK" )
print(my.cluster)
doParallel::registerDoParallel(cl = my.cluster)
foreach::getDoParRegistered()
foreach::getDoParWorkers()

# run for all and time
begin<-Sys.time()
x<- foreach(i= 1:length(allPlants$names), 
            .combine = "rbind", 
            .packages = c("dplyr","mgcv","geometry","factoextra")) %dopar% {
  res <- computePlantImpact(allPlants$names[i], allPlants$Neophyte[i])
            }

end<-Sys.time()
round(end-begin, 2)

parallel::stopCluster(cl = my.cluster)
#write_csv(x, 'Impact2_new70%_ENS0_reldiff_PCA.csv')
}


```





Run this if all data, then foreach does not work
```{r}
if(!fast){

allPlantsImpact <-  data.frame(taxa = character(), Estimate = numeric(), StdErr = numeric(), `zValue` = numeric(), pr = numeric(), numberOfPlots = integer(), Neophyte= character())

i=1
begin<- Sys.time()
for(i in 1:length(allPlants$names)) {
   res <- computePlantImpact(allPlants$names[i], allPlants$Neophyte[i])
   allPlantsImpact <- rbind(allPlantsImpact, res)
}
end<- Sys.time()
round(end-begin)
x<- allPlantsImpact

#write.csv(x, 'Impact2_ENS0.csv')
x <- read_csv('I:/Impact_1980.csv')
}
```

Remove genus level observations
```{r}
# remove genus data
library(vegdata)
check <-vegdata::parse.taxa(unique(x$taxa))
genus <- check[is.na(check$epi1),]
x <- x[!x$taxa %in% genus$original,]
```



## 2.3 Significance
```{r}
# We cannot assume normality
# check assumption normality neophyte classes
ggplot(x, aes(x=(RelDiff), group= Neophyte, color=Neophyte, fill= Neophyte))+
  geom_histogram(aes(y=..density..), alpha=0.5)
# check assumption normality classes
ggplot(x, aes(x=RelDiff, group= class, color=class, fill= class))+
    geom_histogram(aes(y=stat(density)),position="identity", alpha=0.5)

# perform leveneTest to test whether there is homgeneity of variances
car::leveneTest(RelDiff ~ Neophyte, x)
shapiro.test(x$RelDiff[x$Neophyte=="intra"])
shapiro.test(x$RelDiff[x$Neophyte=="extra"])
#shapiro.test(x$RelDiff[x$Neophyte=="native"])


# perform Whelch ANOVA --> this only possible for one variable
# if we want to combine both class and neophyte perform ranked ANOVA
oneway.test(RelDiff ~ Neophyte, data = x, var.equal = FALSE)
rstatix::games_howell_test(data = x, RelDiff ~ Neophyte)

# plot
ggplot(x, aes(Neophyte, RelDiff, color=Neophyte, fill=Neophyte))+
  geom_boxplot(alpha=0.2) +
  theme_classic()

# ranked anova
ranked <- aov(rank(RelDiff) ~ Neophyte+class, x)
hist(ranked$residuals,breaks=100 )
summary(ranked)
TukeyHSD(ranked)
```


```{r}
# load phylogenetic data
phylo <- read_csv("phylo.csv")
x[, c(14,15)] <- phylo[match(x$taxa, phylo$name), 6:7]
colnames(x)[14:15]<- c("genus","family")

# glmm
model <- lmer((RelDiff) ~ -1+ Neophyte+class + (1|family/genus), data= x)
summary(model)

emmeans::emmeans(model, pairwise ~ Neophyte)

# check assumptions
simulation <- DHARMa::simulateResiduals(model)
plot(simulation)

# check pairwise differences
emmeans_results <- emmeans(model, pairwise ~ Neophyte)
summary(emmeans_results)

# number of observations
table(x$Neophyte)

set.seed(1)

# we will 'bootstrap' or results using 1000 replications
result <- data.frame(contrast = character(), estimate = numeric(), SE= numeric(), df=numeric(), t.ratio=numeric(), p.value= numeric())
# Counter for successful runs
successful_runs <- 0

# Run until we get 1000 successful models
while (successful_runs < 1000) {
# sample natives
natives <- x[x$Neophyte=="native",]
natives <- natives[sample(nrow(natives),1000, replace=F),]
# sample intras
intras <- x[x$Neophyte=="intra",]
intras <- intras[sample(nrow(intras),1000, replace=T),]
# sample extras
extras <- x[x$Neophyte=="extra",]
extras <- extras[sample(nrow(extras),1000, replace=T),]
all <- rbind(natives, intras, extras)

# model again
model <- lmer((RelDiff) ~ -1+ Neophyte+class + (1|family/genus), data= all)

summary(model)

if(isSingular(model)) next

# plot(DHARMa::simulateResiduals(model))

# check pairwise differences
emmeans_results <- emmeans::emmeans(model, pairwise ~ Neophyte)
# save in data frame
sum <- summary(emmeans_results)$contrasts
# add to large table
result <- rbind(result, sum)

successful_runs <- successful_runs +1 
}



# look at aggregated results (mean and sd)
aggregated_result <- aggregate(. ~ contrast, data = result, FUN = function(x) c(mean = mean(x), sd = sd(x)))

# assess number of significant
result$significant <- result$p.value < 0.001
table(result$significant)

result |> group_by(contrast)|> summarise(n_t = sum(significant)/length(significant))
```


# 3 PLOT
## 3.1 Estimate
```{r}
x <- x %>% mutate(Species = factor(Neophyte, 
                          levels = c("native", "intra","extra"),
                          labels = c("native in the country", 
                                     "intra-European neophyte", 
                                     "extra-European neophyte")))
```



## 3.2 Plot
```{r}
# take cover classes
cover_class <- unique(x$class)
cover_class

# if not for loop, choose i value
i=6

# can be done with for loop, but than it is hard to change some parameters so better not to
#for(i in 1:6){
  
# create a vector for the title
index <- case_when(
  i == 1  ~ "Very low cover",  
  i == 2~ "Low cover"  ,
  i == 3 ~ "Medium cover"  ,
  i == 4 ~ "High cover"  ,
  i == 5~ "Very high cover" ,
  i == 6~ "Dominant cover")
  
# downsize dataset 
Dataset <- x[x$class==cover_class[i],]
  
# create title
title <- paste(index)
class <- paste("]",cover_class[i], "]", sep="")

# test differences and significance
result<- rstatix::welch_anova_test(Dataset, RelDiff ~ Neophyte )
result
rstatix::games_howell_test(data= Dataset, RelDiff ~ Neophyte)

# glmm
model <- lmer(RelDiff ~ Neophyte + (1|family/genus), Dataset)
summary(model)

simulation <- DHARMa::simulateResiduals(model)
plot(simulation)

# check pairwise differences
emmeans_results <- emmeans::emmeans(model, pairwise ~ Neophyte)
summary(emmeans_results)

table(Dataset$Neophyte)


# we will 'bootstrap' or results using 1000 replications
result <- data.frame(contrast = character(), estimate = numeric(), SE= numeric(), df=numeric(), t.ratio=numeric(), p.value= numeric(), singular= factor())

result_2 <- as.data.frame(matrix(nrow=0, ncol=6))
colnames(result_2)<- c(colnames(summary(model)$coefficients), "Neophyte")

# Counter for successful runs
successful_runs <- 0

# Run until we get 1000 successful models
while (successful_runs < 1000) {
  # sample natives
  natives <- Dataset[Dataset$Neophyte=="native",]
  natives <- natives[sample(nrow(natives),200, replace=F),]
  # sample intras
  intras <- Dataset[Dataset$Neophyte=="intra",]
  intras <- intras[sample(nrow(intras),200, replace=T),]
  # sample extras
  extras <- Dataset[Dataset$Neophyte=="extra",]
  extras <- extras[sample(nrow(extras),200, replace=T),]
  all <- rbind(natives, intras, extras)
  
  # model again

  model<- lmer((RelDiff) ~ -1+ Neophyte + (1|family/genus), data= all)
  summary(model)
  
  if(isSingular(model)) next
  
  sum <- as.data.frame(summary(model)$coefficients)
  sum$Neophyte <- c("extra","intra","native")
  
  result_2 <- rbind(result_2, sum)
  
  # Check pairwise differences
  emmeans_results <- emmeans::emmeans(model, pairwise ~ Neophyte)

  # Save results
  sum <- summary(emmeans_results)$contrasts
  
  sum$singular <- isSingular(model)

  # Append to results dataframe
  result <- rbind(result, sum)
  
  successful_runs <- successful_runs+1
}

# look at aggregated results (mean and sd)
aggregated_result <- aggregate(. ~ contrast, data = result, FUN = function(x) c(mean = mean(x), sd = sd(x)))

# assess number of significant
result$significant <- result$p.value < 0.05
table(result$significant)

result <- `Result_ Dominant_cover`

test <- result |> group_by(contrast, significant) |> summarise(n=n(), diff= mean(estimate), sd= sd(estimate), se= sd/sqrt(n))
test

assign(paste("Result_",gsub(" ","_",index)), result)
```


```{r}

# if not for loop, choose i value
i= 1

# can be done with for loop, but than it is hard to change some parameters so better not to
#for(i in 1:6){
  
# create a vector for the title
index <- case_when(
  i == 1  ~ "Very low cover",  
  i == 2~ "Low cover"  ,
  i == 3 ~ "Medium cover"  ,
  i == 4 ~ "High cover"  ,
  i == 5~ "Very high cover" ,
  i == 6~ "Dominant cover")
  
# downsize dataset 
Dataset <- x[x$class==cover_class[i],]
  
# create title
title <- paste(index)
class <- paste("]",cover_class[i], "]", sep="")


max5 <- max(Dataset$RelDiff)
min6 <- min(Dataset$RelDiff)


# plot
p<-ggplot(Dataset, aes(x=Neophyte, y= RelDiff, group = Species,
               color = Species, fill = Species))+
    geom_violin(alpha=0.5, scale="width")+
    geom_boxplot(width= 0.25, alpha=0.8, fill="white")+
    theme_pubr()+
    stat_summary(fun= "mean",
                 geom = "point", aes(group= Neophyte), size=3)+
    scale_colour_manual(values=c("#1E88E5", "#FFC107", "#004D40"))+
    scale_fill_manual(values = c("#1E88E5", "#FFC107", "#004D40")) +
    theme(legend.position = "none")+
    theme(legend.text= element_text(size=12),legend.title =element_text(size=14))+
    annotate("text", x = 1, y = max5 + max5/10, 
             label = "c", size = 4, vjust = 0.5, hjust = 0.5, alpha=1) +
    annotate("text", x = 2, y = max5 + max5/10, 
             label = "b", size = 4, vjust = 0.5, hjust = 0.5, alpha=1)+
    annotate("text", x = 3, y = max5 + max5/10, 
             label = "a", size = 4, vjust = 0.5, hjust = 0.5, alpha=1)+
    annotate("text", x=1, y=max5 + max5/5, 
             label= paste("n=",length(Dataset$Estimate[Dataset$Neophyte=="extra"])), 
             vjust = 0, hjust = 0.5, size=4)+
    annotate("text", x=2, y=max5 + max5/5, 
             label= paste("n=",length(Dataset$Estimate[Dataset$Neophyte=="intra"])), 
             vjust = 0, hjust = 0.5, size=4)+
    annotate("text", x=3, y=max5 + max5/5, 
             label= paste("n=",length(Dataset$Estimate[Dataset$Neophyte=="native"])), 
             vjust = 0, hjust = 0.5, size=4)+
    #labs(subtitle = "Significance level: NS")+
    ylab("Relative impact")+
    ggtitle(title)+
    xlab(NULL)+
    geom_hline(yintercept=0, linetype='dotted', alpha=0.5)+
    theme(plot.title= element_text(hjust=0.01),
      plot.subtitle = element_text( hjust = 0.01))+
    scale_y_continuous(limits=c(min6, max5+max5/5))
  assign(gsub(" ","_",index), p)
  p


  
# arrange all plots and save
plot <- ggarrange(Very_low_cover, Low_cover, Medium_cover, High_cover,
                  Very_high_cover, Dominant_cover, nrow=3, ncol=2, labels= c("a","b", "c","d","e","f"),
                  font.label = list(size = 12), align="hv")

plot
ggsave("Impact.svg", plot= plot, width = 10, height = 10)

# save individually
ggsave("Very_low.png", plot= Very_low_cover, width = 5, height = 3)
ggsave("Low.jpg", plot= Low_cover, width = 5, height = 3)
ggsave("Medium.jpg", plot= Medium_cover, width = 5, height = 3)
ggsave("High.jpg", plot= High_cover, width = 5, height = 3)
ggsave("Very_high.jpg", plot= Very_high_cover, width = 5, height = 3)
ggsave("Dominant.jpg", plot= Dominant_cover, width = 5, height = 3)

```




