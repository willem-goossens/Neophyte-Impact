---
title: "Data preparation"
subtitle: "based on the work of Christian Ledergerber"
author: "Willem Goossens"
date: "`r Sys.Date()`"
output: html_document
---
# 1 LOAD
## 1.1 prepare
We first clean the environment
```{r, echo=T}
rm(list=ls())
eval <- F
```

We load the required libraries
```{r, warning=F, message=F}
library(readr)
library(tidyr)
library(dplyr)
library(magrittr)
library(ggplot2)
library(AER)
library(mgcv)
library(modEvA)
library(doParallel)
library(arsenal)
library(pracma)
library(vegdata)
library(plantlist)
```


## 1.2 Eva Data
We load the data
```{r , message=FALSE, warning=FALSE, eval= eval}
fast <- F
if(fast) {
  eva <- read_delim("../EVA Data/onePromilleEva.csv", "\t")
} else {
  eva <- read_delim("../EVA Data/171_NeophyteInvasions20230216_notJUICE_species.csv", "\t")
}

```


We remove the rows without observations.
```{r, eval= eval}
# Count the number of rows with NA values
numberOfRowsWithoutPlotID <- sum(is.na(eva$PlotObservationID))
# Check rows with NA
# eva[which(is.na(eva$PlotObservationID)),]
# Filter out all rows which don't have a plot ID
eva <- eva[!is.na(eva$PlotObservationID),]
# Count number of plots in eva before data removal
originalPlotNumberEva<- length(unique(eva$PlotObservationID))
```


We update the taxa data
```{r, warning=F, message=FALSE, eval= eval}
# Update taxon group for some species where it was specified incorrectly
taxonGroupCorrections <- read_csv("../Intermediate Data/taxa_taxon_group_corrections.csv")

# What is the location of the species in eva that are specified incorrectly
index <- eva$`Matched concept` %in% taxonGroupCorrections$Matched.concept

# Change to correct for each species
eva$`Taxon group`[index] <- taxonGroupCorrections$NewTaxonGroup[match(eva$`Matched concept`[index], taxonGroupCorrections$Matched.concept)]


# Update taxon group for species that did not have one in EVA
taxonGroupAssignments <- read_csv("../Intermediate Data/taxa_taxon_group_assignments.csv")
index <- eva$`Matched concept` %in% taxonGroupAssignments$Matched.concept
eva$`Taxon group`[index] <- taxonGroupAssignments$TaxonGroup[match(eva$`Matched concept`[index], taxonGroupAssignments$Matched.concept)]


# Some taxon names seem incorrect
taxonNameCorrections <- read_csv("../Neophyte-Impact/Neophyte Assignments/UniqueTaxaEurope-2023-04-23.csv")

# give the species name from taxon name corrections to eva in the species column
# to lower makes sure all data is written without capitals
# match gives vector with position of argument eva in taxonNameCorrections, and does this for the total length of eva
eva$species <- taxonNameCorrections$species[match(tolower(eva$`Matched concept`), tolower(taxonNameCorrections$Matched.concept))]

# some data of species is.na, we assign for these the values of the matched concept
eva$species[is.na(eva$species)] <- eva$`Matched concept`[is.na(eva$species)] 

# fix problem with plant not present in neophyte file from irena (only a handful of plant observations in EVA)
# In file Irena some write 'exclude'
```



We only keep vascular plants and remove the columns in which this data is designated.
```{r, eval= eval}
length(eva$species[!eva$`Taxon group`=="Vascular plant"])
eva <- eva[eva$`Taxon group` == "Vascular plant",!names(eva) %in% c("Taxon group", "Taxon group ID")]
```


```{r, eval= eval}
# Load new eva database
new <- read_csv("eva_euro_own2.csv", show_col_types = FALSE)

# Eva names
eva_names <- as.data.frame(eva$species[!duplicated(eva$species)])
colnames(eva_names) <- "species"
eva_names$old_name <- eva$`Matched concept`[match(eva_names$species, eva$species)]

# New names
new_names <- as.data.frame(new$`Matched concept`[!duplicated(new$`Matched concept`)])
colnames(new_names)<- "old_name"
new_names$species <- new$species[match(new_names$`old_name`, new$`Matched concept`)]
new_names$irena <- new$irena[match(new_names$species, new$species)]


# check which names were in the new database but not in eva --> 1542 species
not_eva <- new_names[!new_names$species %in% eva_names$species,]
# it is possible that this is related to difference with data irena so check
not_irena_eva <- not_eva[!not_eva$irena %in% eva_names$species,]
# and additional 1542-465=1077 species were changed by us but originally got these names from Irena
# we additionally check whether these species are present in matched names and were just changed
not_irena_eva_old <- not_irena_eva[not_irena_eva$old_name %in% eva_names$old_name,]
# true for 145 species
# so overall only 464 - 149= 315 species were new in our database and not in the old one
# new database --> 324 species
check <- not_irena_eva[!not_irena_eva$old_name %in% eva_names$old_name,]

# there are some inherent problems with our classification, as some species are classified wrong by POWO


# we check how many observations these are
check <- new[new$species %in% check$species,]
check <- check |> group_by(species, `Matched concept`) |> summarise(n=n())

# we create a list of species where species and matched concept names differ
check_list<- (setdiff(check$species,check$`Matched concept`))
# check these species
check <- check[check$species %in% check_list,]
# the ones to be removed are in 2.1
```



```{r, eval= eval}
# remove new species from
not_new <- eva_names[!eva_names$species %in% new_names$species,]
# maybe due to irena file
not_irena_new <- not_new[!not_new$species %in% new_names$irena,]
# 1160-527 species were in eva
# we additionally check whether these species are present in matched names and were just changed
not_irena_new_old <- not_irena_new[not_irena_new$old_name %in% new_names$old_name,]
# true for 484 species
# so overall only 43 species were in old database and not in the new one
check <- not_irena_new[!not_irena_new$old_name %in% new_names$old_name,]

# we check how many observations these are 
check <- eva[eva$species %in% check$species,]
check <- check |> group_by(species, `Matched concept`) |> summarise(n=n())

# list checked, looks okay
```


## 1.3 New data
```{r}
rm(list = setdiff(ls(), "eva"))
new <- read_csv("eva_ESy.csv", show_col_types = FALSE)
eva <- new
```



Here we decide on which layers to keep
```{r}
# sum all species over layers if present in multiple layers
numberOfRowsTreeLayer<- length(eva$Layer[eva$Layer %in% c(1:3)])

Layerremove=F
if(Layerremove){
  numberOfRowsTreeLayer<- length(eva$Layer[eva$Layer %in% c(1:3)])
  eva <- eva |> group_by(PlotObservationID, species) |> filter(Layer %in% c(0,4:9))
}

# Which rows contain duplicates
numberOfRowsDuplicates<- sum((eva|> group_by(PlotObservationID)|> mutate(duplicated = duplicated(species)))$duplicated)
Layersum=T
if(Layersum){
  eva <- eva |> group_by(PlotObservationID, species, `Matched concept`, irena, name, source) |> summarise(`Cover %`= sum(`Cover %`))
} else {
  eva <- eva |> select(PlotObservationID, species, `Matched concept`, irena, name, source,`Cover %`)
}

head(eva)

# remove species with 0 cover
numberOfZeroCover <- length(eva$PlotObservationID[eva$`Cover %`=="0"])
# look at from which datasets these come --> "Belgium-forest" "Belgium-INBOVEG" "GrassVeg.DE" "Turkey NFVDT"--> wrong entering --> remove
# unique(header$Dataset[header$PlotObservationID %in% (eva$PlotObservationID[eva$`Cover %`=="0"])])
coverzero=T
if(coverzero){
  eva<- eva[!eva$`Cover %`=="0", ]
}
```


Compute total cover for each plot.
```{r}
totalCover <- 
  eva %>% 
  group_by(PlotObservationID) %>% 
  summarise(totalCover = sum(`Cover %`))

# Check distribution (we max on 2000, but total cover goes up to 25000)
hist(totalCover$totalCover[totalCover$totalCover> 750 & totalCover$totalCover<2000 ])
# We calculate the number of plots in which this occurs
numberOfTooLargeCover<- length(totalCover$totalCover[totalCover$totalCover> 900])

# We check the datasets --> many datasets have more than 900 (64 out of 320)
# unique(header$Dataset[header$PlotObservationID %in% (totalCover$PlotObservationID[totalCover$totalCover> 900])])

# We check the plots (only largest subset)
eva[eva$PlotObservationID %in% totalCover$PlotObservationID[totalCover$totalCover> 9000],]

maxcover=T
if(maxcover){
  eva<- eva[!eva$PlotObservationID %in% totalCover$PlotObservationID[totalCover$totalCover> 900],] 
}
```


## 1.4 Header Data
Read in the header information. Look at and remove plots for which:

-   Area is NA or smaller than 0
-   Area is larger than 1000 m²
-   The longitude or latitude data is not known
-   The plot is not assigned to a region
-   The plot only contains presence/absence data

```{r, message=F, warning=F}
header <- read_delim("../EVA Data/171_NeophyteInvasions20230216_notJUICE_header.csv", "\t")
totalNumberOfPlots <- length(header$PlotObservationID)

# Plot sizes too small/ inexistent
plotsWithoutPlotSize <- is.na(header$`Relevé area (m²)`) | header$`Relevé area (m²)` <= 0
numberOfPlotsWithoutPlotSize <- sum(plotsWithoutPlotSize)

# Plot sizes too large (https://onlinelibrary.wiley.com/doi/full/10.1002/ece3.8965)
tooLargePlots <- header$`Relevé area (m²)` > 1000
numberOfTooLargePlots<- sum(tooLargePlots, na.rm=T)

# Plots without coordinates
plotsWithoutLocation <- is.na(header$Latitude) | is.na(header$Longitude)
numberOfPlotsWithoutLocation <- sum(plotsWithoutLocation)

# Check whether the amount of observation plots correspond
# This is the data made in 3_Region_check (here we also removed all data without coordinates)
plotsRegionAssignments <- read_csv("../Intermediate Data/plot_to_region_assignment.csv")
# Error message if the two are not the same
if( sum(header$PlotObservationID[!plotsWithoutLocation] != plotsRegionAssignments$PlotObservationID) > 0) {
  message("Error: plotsRegionAssignments expected to contain the same plots as contained in header data.")
}

# Count number of plots unassigned
# create logical vector of header length
plotsWithoutRegionAssignment <- vector(mode = "logical", length = length(header$PlotObservationID))
# make true when the plot has no region, taking into consideration that some plots have no coordinates
plotsWithoutRegionAssignment[!plotsWithoutLocation] <- is.na(plotsRegionAssignments$Region)
numberOfPlotsWithoutRegionAssignment = sum(plotsWithoutRegionAssignment)

# Remove only Presence/ Absence data and NA data
namesForPresenceAbsence <- c("Presence/Absence", "Presentie/Absentie", NA)
# logical vector with length header 
plotsWithPresenceAbsenceOnly <- header$`Cover abundance scale` %in% namesForPresenceAbsence
numberOfPlotsWithoutCoverInformation <- sum(plotsWithPresenceAbsenceOnly)

# sum all plots to be removed
allPlotsToBeRemoved <- plotsWithoutPlotSize | tooLargePlots | plotsWithoutLocation | plotsWithPresenceAbsenceOnly | plotsWithoutRegionAssignment
totalNumberRemoved <- sum(allPlotsToBeRemoved)
```


`r numberOfPlotsWithoutPlotSize` of the plots do not contain a size, `r numberOfTooLargePlots` were larger than 1000m² and therefore most likely no plots, `r numberOfPlotsWithoutLocation` of the plots do not have a location, `r numberOfPlotsWithoutRegionAssignment` cannot be assigned to one of the neophyte regions and `r numberOfPlotsWithoutCoverInformation` of the plots do not contain cover data. All these plots (`r totalNumberRemoved`) are removed:
```{r}
header <- header[!allPlotsToBeRemoved,]
```

We also add the region to the data for analysis and change the region and dataset to a factor.
```{r}
header <- left_join(header, plotsRegionAssignments, by = "PlotObservationID")
header$Region <- as.factor(header$Region)
header$Dataset <- as.factor(header$Dataset)
```

Finally, we will keep only the plots that are still available in both Eva and Header
```{r}
plotsInEvaAndHeader <- intersect(eva$PlotObservationID, header$PlotObservationID)
eva <- eva[eva$PlotObservationID %in% plotsInEvaAndHeader,]
header <- header[header$PlotObservationID %in% plotsInEvaAndHeader,]
```
After filtering `r length(header$PlotObservationID)` plots remain.


# 2 INDICATORS
## 2.1 Eive
Reading in the EIVE data and explore data by boxplotting the moisture (M), nitrogen (N), pH (R), light (L) and temperature (T) variables.
```{r, message=F, fig.show = "hide"}
# 08 contains the indicator values for position and width
eive <- read_delim("../EIVE Data/EIVE_Paper_1.0_SM_08.csv", ",")
# data contains n --> number of sources, nw--> niche width and ''--> value

par(mfrow = c(1,1))
boxplot(eive$`EIVEres-M`, xlab="M") # outliers above
boxplot(eive$`EIVEres-N`, xlab="N") # little outliers
boxplot(eive$`EIVEres-R`, xlab="R") # outliers below
boxplot(eive$`EIVEres-L`, xlab="L") # outliers below
boxplot(eive$`EIVEres-T`, xlab="T") # little outliers
par(mfrow=c(1,1))
# The EIVE values are OK balanced with some outliers. No extreme skewness to be expected for the average indicator values at the plot level.
```



Extend eva with columns from EIVE.
```{r, fig.show = "hide"}
# match gives position of species in eva in eive

# First we match our own 'species column', which has the Euro Med data added with powo and some data from Irena
# Later 'the matched concept' was added
# positions
eva$EIVEresM <- eive$`EIVEres-M`[match(eva$name, eive$TaxonConcept)]
eva$EIVEresN <- eive$`EIVEres-N`[match(eva$name, eive$TaxonConcept)]
eva$EIVEresR <- eive$`EIVEres-R`[match(eva$name, eive$TaxonConcept)]
eva$EIVEresL <- eive$`EIVEres-L`[match(eva$name, eive$TaxonConcept)]
eva$EIVEresT <- eive$`EIVEres-T`[match(eva$name, eive$TaxonConcept)]

# niche widths
eva$EIVEnwM <- eive$`EIVEres-M.nw3`[match(eva$name, eive$TaxonConcept)]
eva$EIVEnwN <- eive$`EIVEres-N.nw3`[match(eva$name, eive$TaxonConcept)]
eva$EIVEnwR <- eive$`EIVEres-R.nw3`[match(eva$name, eive$TaxonConcept)]
eva$EIVEnwL <- eive$`EIVEres-L.nw3`[match(eva$name, eive$TaxonConcept)]
eva$EIVEnwT <- eive$`EIVEres-T.nw3`[match(eva$name, eive$TaxonConcept)]

# check names
eva$eive_name <- eive$TaxonConcept[match(eva$name, eive$TaxonConcept)]
new_names <- eva[is.na(eva$eive_name),]




# which species are additionally present when using species --> 345 additional species
extra<- new_names[!is.na(match(new_names$`species`, eive$TaxonConcept)),]
extra <- unique(extra[,2:6])
extra_species <- extra

# Second we add species data for these species
eva$EIVEresM[eva$species %in% extra$species] <- eive$`EIVEres-M`[match(eva$`species`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEresN[eva$species %in% extra$species] <- eive$`EIVEres-N`[match(eva$`species`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEresR[eva$species %in% extra$species] <- eive$`EIVEres-R`[match(eva$`species`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEresL[eva$species %in% extra$species] <- eive$`EIVEres-L`[match(eva$`species`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEresT[eva$species %in% extra$species] <- eive$`EIVEres-T`[match(eva$`species`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]

# niche widths
eva$EIVEnwM[eva$species %in% extra$species] <- eive$`EIVEres-M.nw3`[match(eva$`species`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEnwN[eva$species %in% extra$species] <- eive$`EIVEres-N.nw3`[match(eva$`species`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEnwR[eva$species %in% extra$species] <- eive$`EIVEres-R.nw3`[match(eva$`species`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEnwL[eva$species %in% extra$species] <- eive$`EIVEres-L.nw3`[match(eva$`species`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEnwT[eva$species %in% extra$species] <- eive$`EIVEres-T.nw3`[match(eva$`species`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]

# check new names
eva$eive_name[eva$species %in% extra$species]  <- eive$TaxonConcept[match(eva$species[eva$species %in% extra$species] , eive$TaxonConcept)]
length(eive$TaxonConcept[match(eva$irena[eva$species %in% extra_species$species] , eive$TaxonConcept)])
new_names <- eva[is.na(eva$eive_name),]
# check previous annotation
extra<- new_names[!is.na(match(new_names$`species`, eive$TaxonConcept)),]




# which species are additionally present when using irena --> 132 additional species
extra<- new_names[!is.na(match(new_names$`irena`, eive$TaxonConcept)),]
extra <- unique(extra[,2:6])
extra_irena <- extra

# Third we add eva irena data for these species
eva$EIVEresM[eva$species %in% extra$species] <- eive$`EIVEres-M`[match(eva$`irena`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEresN[eva$species %in% extra$species] <- eive$`EIVEres-N`[match(eva$`irena`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEresR[eva$species %in% extra$species] <- eive$`EIVEres-R`[match(eva$`irena`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEresL[eva$species %in% extra$species] <- eive$`EIVEres-L`[match(eva$`irena`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEresT[eva$species %in% extra$species] <- eive$`EIVEres-T`[match(eva$`irena`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]

# niche widths
eva$EIVEnwM[eva$species %in% extra$species] <- eive$`EIVEres-M.nw3`[match(eva$`irena`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEnwN[eva$species %in% extra$species] <- eive$`EIVEres-N.nw3`[match(eva$`irena`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEnwR[eva$species %in% extra$species] <- eive$`EIVEres-R.nw3`[match(eva$`irena`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEnwL[eva$species %in% extra$species] <- eive$`EIVEres-L.nw3`[match(eva$`irena`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEnwT[eva$species %in% extra$species] <- eive$`EIVEres-T.nw3`[match(eva$`irena`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
# check new names
eva$eive_name[eva$species %in% extra$species]  <- eive$TaxonConcept[match(eva$`irena`[eva$species %in% extra$species],
                                                                          eive$TaxonConcept)]
length(eive$TaxonConcept[match(eva$`irena`[eva$species %in% extra$species],eive$TaxonConcept)])
new_names <- eva[is.na(eva$eive_name),]
# check previous annotation
extra<- new_names[!is.na(match(new_names$`irena`, eive$TaxonConcept)),]



# finally lets check the 'Matched concept' name --> 6 additional species
extra<- new_names[!is.na(match(new_names$`Matched concept`, eive$TaxonConcept)),]
extra <- unique(extra[,2:4])
extra_matched <- extra

# Third we add eva matched concept data for these species
eva$EIVEresM[eva$species %in% extra$species] <- eive$`EIVEres-M`[match(eva$`Matched concept`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEresN[eva$species %in% extra$species] <- eive$`EIVEres-N`[match(eva$`Matched concept`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEresR[eva$species %in% extra$species] <- eive$`EIVEres-R`[match(eva$`Matched concept`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEresL[eva$species %in% extra$species] <- eive$`EIVEres-L`[match(eva$`Matched concept`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEresT[eva$species %in% extra$species] <- eive$`EIVEres-T`[match(eva$`Matched concept`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]

# niche widths
eva$EIVEnwM[eva$species %in% extra$species] <- eive$`EIVEres-M.nw3`[match(eva$`Matched concept`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEnwN[eva$species %in% extra$species] <- eive$`EIVEres-N.nw3`[match(eva$`Matched concept`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEnwR[eva$species %in% extra$species] <- eive$`EIVEres-R.nw3`[match(eva$`Matched concept`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEnwL[eva$species %in% extra$species] <- eive$`EIVEres-L.nw3`[match(eva$`Matched concept`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
eva$EIVEnwT[eva$species %in% extra$species] <- eive$`EIVEres-T.nw3`[match(eva$`Matched concept`[eva$species %in% extra$species],
                                                                           eive$TaxonConcept)]
# check new names
eva$eive_name[eva$species %in% extra$species]  <- eive$TaxonConcept[match(eva$`Matched concept`[eva$species %in% extra$species],
                                                                          eive$TaxonConcept)]
length(eive$TaxonConcept[match(eva$`Matched concept`[eva$species %in% extra$species],eive$TaxonConcept)])
new_names <- eva[is.na(eva$eive_name),]

# check previous annotation
extra<- new_names[!is.na(match(new_names$`Matched concept`, eive$TaxonConcept)),]
```


```{r, fig.show = "hide"}
# look at total number of species in eive
length(unique(eive$TaxonConcept[match(eva$name, eive$TaxonConcept)]))
length(unique(eive$TaxonConcept[match(eva$species, eive$TaxonConcept)]))
length(unique(eive$TaxonConcept[match(eva$irena, eive$TaxonConcept)]))
length(unique(eive$TaxonConcept[match(eva$`Matched concept`,eive$TaxonConcept)]))

# check total amount of observations
sum(!is.na(eva$species[match(eva$name, eive$TaxonConcept)]))
sum(!is.na(eva$species[match(eva$species, eive$TaxonConcept)]))
sum(!is.na(eva$species[match(eva$irena, eive$TaxonConcept)]))
sum(!is.na(eva$species[match(eva$`Matched concept`, eive$TaxonConcept)]))

# no names
no_eive <-  eva[is.na(eva$eive_name),]
no_eive <- unique(no_eive[, 2:6])

# check against the length of eva names
eva_names <- unique(eva[,2:6])

percentOfSpeciesEvaInEive <- 1- nrow(no_eive)/ nrow(eva_names)

# Look at number of observations not in EIVE
numberOfPlantsInEvaFoundInEive <- sum(!(is.na(eva$EIVEresM) | 
                                              is.na(eva$EIVEresN) | 
                                              is.na(eva$EIVEresR) | 
                                              is.na(eva$EIVEresL) | 
                                              is.na(eva$EIVEresT)))
percentEvaInEive<- numberOfPlantsInEvaFoundInEive/length(eva$PlotObservationID)
```


`r numberOfPlantsInEvaFoundInEive` of the `r length(eva$PlotObservationID)` plant observations in Eva have indicator values in EIVE.


Look at unique species to see whether neophytes are not with less relative representatives
This has to be performed with old data, since new data from Irena (January 2024) is only on the full plot data (which is made later in this file, after removing some plots etc)
```{r}
# Load file
taxonNameCorrections <- read_csv("../Neophyte-Impact/Neophyte Assignments/UniqueTaxaEurope-2023-04-23.csv", show_col_types = FALSE)

# downsize to ease calculations
test<- eva[, c("species", "irena","EIVEresM","EIVEresN","EIVEresR","EIVEresL","EIVEresT")]
# remove duplicates species
test<- test[!duplicated(test$species),]
# join with taxonNameCorrections
test<- left_join(test, taxonNameCorrections, by=c("irena"="species"))

test$statusEurope<- as.character(test$statusEurope)
# percent of natives without data
length(test$species[(test$statusEurope=="native") & (is.na(test$EIVEresL)|                                                is.na(test$EIVEresM)|is.na(test$EIVEresN)|is.na(test$EIVEresR)|is.na(test$EIVEresT))])/length(test$species[test$statusEurope=="native"])

# percent of neophytes without data
length(test$species[(test$statusEurope=="neo") & (is.na(test$EIVEresL)| is.na(test$EIVEresM)|is.na(test$EIVEresN)|is.na(test$EIVEresR)|is.na(test$EIVEresT))])/length(test$species[test$statusEurope=="neo"])

# percent of archeotypes without data
length(test$species[(test$statusEurope=="arch") & (is.na(test$EIVEresL)| is.na(test$EIVEresM)|is.na(test$EIVEresN)|is.na(test$EIVEresR)|is.na(test$EIVEresT))])/length(test$species[test$statusEurope=="arch"])
```


## 2.2 Div
Reading in the disturbance indicator values en plotting severity and frequency.
```{r, messagge=F, warning=F, message=F, fig.show = "hide"}
div <- read_delim("../Disturbance Data/disturbance_indicator_values.csv", ",")

par(mfrow = c(1,1))
# Relatively balanced
boxplot(div$Disturbance.Severity, xlab="Severity")
boxplot(div$Disturbance.Frequency, xlab="Frequency")

# more skewed (check with hist)
boxplot(div$Mowing.Frequency, xlab="Mowing fr")
hist(div$Mowing.Frequency, xlab="Mowing fr")

# check others
boxplot(div$Grazing.Pressure, xlab="Grazing Pr")
boxplot(div$Soil.Disturbance, xlab="Soil dist")

# oke balanced still
hist(div$Grazing.Pressure, xlab="Grazing Pr")
hist(nthroot(div$Soil.Disturbance, 1), xlab="Soil dist")
```


Extend eva with columns from disturbance indicator values:
```{r}
# expand first with our species classification
eva$Disturbance.Severity <- div$Disturbance.Severity[match(eva$species, div$species)]
eva$Disturbance.Severity.herblayer <- div$Disturbance.Severity.herblayer[match(eva$name, div$species)]
eva$Disturbance.Frequency <- div$Disturbance.Frequency[match(eva$name, div$species)]
eva$Disturbance.Frequency.herblayer <- div$Disturbance.Frequency.herblayer[match(eva$name, div$species)]
eva$Grazing.Pressure <- div$Grazing.Pressure[match(eva$name, div$species)]
eva$Mowing.Frequency <- div$Mowing.Frequency[match(eva$name, div$species)]
eva$Soil.Disturbance <- div$Soil.Disturbance[match(eva$name, div$species)]


# check names
eva$div_name <- div$species[match(eva$name, div$species)]
length(eva$div_name[!is.na(eva$div_name)])
new_names <- eva[is.na(eva$div_name),]




# which species are additionally present when using species
extra<- new_names[!is.na(match(new_names$`irena`, div$species)),]
extra <- unique(extra[,2:4])
extra_species_div <- extra

# expand second with species species classification
eva$Disturbance.Severity[eva$species %in% extra$species] <- 
  div$Disturbance.Severity[match(eva$species[eva$species %in% extra$species], div$species)]
eva$Disturbance.Severity.herblayer[eva$species %in% extra$species] <- 
  div$Disturbance.Severity.herblayer[match(eva$species[eva$species %in% extra$species], div$species)]
eva$Disturbance.Frequency[eva$species %in% extra$species] <- 
  div$Disturbance.Frequency[match(eva$species[eva$species %in% extra$species], div$species)]
eva$Disturbance.Frequency.herblayer[eva$species %in% extra$species] <- 
  div$Disturbance.Frequency.herblayer[match(eva$species[eva$species %in% extra$species], div$species)]
eva$Grazing.Pressure[eva$species %in% extra$species] <- 
  div$Grazing.Pressure[match(eva$species[eva$species %in% extra$species], div$species)]
eva$Mowing.Frequency[eva$species %in% extra$species] <- 
  div$Mowing.Frequency[match(eva$species[eva$species %in% extra$species], div$species)]
eva$Soil.Disturbance[eva$species %in% extra$species] <- 
  div$Soil.Disturbance[match(eva$species[eva$species %in% extra$species], div$species)]

# check names
eva$div_name[eva$species %in% extra$species] <- div$species[match(eva$species[eva$species %in% extra$species], div$species)]
length(div$species[match(eva$species[eva$species %in% extra$species], div$species)])
new_names <- eva[is.na(eva$div_name),]
extra<- new_names[!is.na(match(new_names$`species`, div$species)),]





# which species are additionally present when using irena
extra<- new_names[!is.na(match(new_names$`irena`, div$species)),]
extra <- unique(extra[,2:4])
extra_irena_div <- extra

# expand second with irena species classification
eva$Disturbance.Severity[eva$species %in% extra$species] <- 
  div$Disturbance.Severity[match(eva$irena[eva$species %in% extra$species], div$species)]
eva$Disturbance.Severity.herblayer[eva$species %in% extra$species] <- 
  div$Disturbance.Severity.herblayer[match(eva$irena[eva$species %in% extra$species], div$species)]
eva$Disturbance.Frequency[eva$species %in% extra$species] <- 
  div$Disturbance.Frequency[match(eva$irena[eva$species %in% extra$species], div$species)]
eva$Disturbance.Frequency.herblayer[eva$species %in% extra$species] <- 
  div$Disturbance.Frequency.herblayer[match(eva$irena[eva$species %in% extra$species], div$species)]
eva$Grazing.Pressure[eva$species %in% extra$species] <- 
  div$Grazing.Pressure[match(eva$irena[eva$species %in% extra$species], div$species)]
eva$Mowing.Frequency[eva$species %in% extra$species] <- 
  div$Mowing.Frequency[match(eva$irena[eva$species %in% extra$species], div$species)]
eva$Soil.Disturbance[eva$species %in% extra$species] <- 
  div$Soil.Disturbance[match(eva$irena[eva$species %in% extra$species], div$species)]

# check names
eva$div_name[eva$species %in% extra$species] <- div$species[match(eva$irena[eva$species %in% extra$species], div$species)]
length(div$species[match(eva$irena[eva$species %in% extra$species], div$species)])
new_names <- eva[is.na(eva$div_name),]
extra<- new_names[!is.na(match(new_names$`irena`, div$species)),]




# which species are additionally present when using 'Matched concept'
extra<- new_names[!is.na(match(new_names$`Matched concept`, div$species)),]
extra <- unique(extra[,2:4])
extra_matched_div <- extra

# expand second with irena species classification
eva$Disturbance.Severity[eva$species %in% extra$species] <- 
  div$Disturbance.Severity[match(eva$`Matched concept`[eva$species %in% extra$species], div$species)]
eva$Disturbance.Severity.herblayer[eva$species %in% extra$species] <- 
  div$Disturbance.Severity.herblayer[match(eva$`Matched concept`[eva$species %in% extra$species], div$species)]
eva$Disturbance.Frequency[eva$species %in% extra$species] <- 
  div$Disturbance.Frequency[match(eva$`Matched concept`[eva$species %in% extra$species], div$species)]
eva$Disturbance.Frequency.herblayer[eva$species %in% extra$species] <- 
  div$Disturbance.Frequency.herblayer[match(eva$`Matched concept`[eva$species %in% extra$species], div$species)]
eva$Grazing.Pressure[eva$species %in% extra$species] <- 
  div$Grazing.Pressure[match(eva$`Matched concept`[eva$species %in% extra$species], div$species)]
eva$Mowing.Frequency[eva$species %in% extra$species] <- 
  div$Mowing.Frequency[match(eva$`Matched concept`[eva$species %in% extra$species], div$species)]
eva$Soil.Disturbance[eva$species %in% extra$species] <- 
  div$Soil.Disturbance[match(eva$`Matched concept`[eva$species %in% extra$species], div$species)]

# check names
eva$div_name[eva$species %in% extra$species] <- div$species[match(eva$`Matched concept`[eva$species %in% extra$species], div$species)]
length(div$species[match(eva$`Matched concept`[eva$species %in% extra$species], div$species)])
new_names <- eva[is.na(eva$div_name),]
extra<- new_names[!is.na(match(new_names$`Matched concept`, div$species)),]
```


```{r}
# look at total number of species in eive
length(unique(div$species[match(eva$name, div$species)]))
length(unique(div$species[match(eva$species, div$species)]))
length(unique(div$species[match(eva$irena, div$species)]))
length(unique(div$species[match(eva$`Matched concept`,div$species)]))

# check total amount of observations
sum(!is.na(eva$species[match(eva$name, div$species)]))
sum(!is.na(eva$species[match(eva$species, div$species)]))
sum(!is.na(eva$species[match(eva$irena, div$species)]))
sum(!is.na(eva$species[match(eva$`Matched concept`,div$species)]))

# no names
no_div <-  eva[is.na(eva$div_name),]
no_div <- unique(no_div[, 2:4])

# check against the length of eva names
percentOfSpeciesEvaInDiv <- 1- nrow(no_div)/ nrow(eva_names)

# and amount of observations
numberOfPlantsInEvaFoundInDiv <- sum(!is.na(eva$Disturbance.Severity))
percentEvaInDiv<- numberOfPlantsInEvaFoundInDiv/length(eva$Disturbance.Severity)
```

`r numberOfPlantsInEvaFoundInDiv` of the `r length(eva$PlotObservationID)` plant observations in Eva have disturbance indicator value.

Look at unique species to see whether neophytes are not with less relative representatives
```{r}
# reduce eva
test<- eva[, c("species","irena", "Disturbance.Severity")]
# only unique species
test<- test[!duplicated(test$species),]
test<- left_join(test, taxonNameCorrections, by=c("irena"="species"))

# make status a character
test$statusEurope<- as.character(test$statusEurope)
# percent of natives without data
length(test$species[(test$statusEurope=="native") & (is.na(test$Disturbance.Severity))])/length(test$species[test$statusEurope=="native"])

# percent of neophytes without data
length(test$species[(test$statusEurope=="neo") & (is.na(test$Disturbance.Severity))])/length(test$species[test$statusEurope=="neo"])

# percent of archeotypes without data
length(test$species[(test$statusEurope=="arch") & (is.na(test$Disturbance.Severity))])/length(test$species[test$statusEurope=="arch"])
```


# 3 ANALYSIS
## 3.1 Aggregate
Aggregating EVA (#plant per plot and average indicator values) and calculating all kinds of weighting methods for the Eive values.

We have only four options (first three are weighted means)
-   square root of coverage* IV
-   1/niche width * IV
-   square root of coverage* 1/niche width * IV
-   normal mean IV
Following Scherrer et al (2019), Kafer et al (2004) and Descombes et al (2020), the mean indicator value is best correlated with reality but criticized by Tolygesi (2014) 
Following Saatkamp et al (2022), 1/ niche width very good

```{r}
# Function to compute the square root of coverage weighted indicator value 
# Calculate the weight for every species in the plot, then take the indicator value and finally compute the weighted mean
computeSquareRootWeightedMean <- function(indicatorValue, coverage) {
  weights <- sqrt(coverage[!is.na(indicatorValue)])
  indicators <- indicatorValue[!is.na(indicatorValue)]
  weighted.mean(indicators, weights)
}

# Function to compute 1/niche-width weighted mean
NWwmean <- function(indicatorValue, nicheWidth) {
  weights <- 1 / nicheWidth[!is.na(indicatorValue)]
  indicators <- indicatorValue[!is.na(indicatorValue)]
  weighted.mean(indicators, weights)
}

# Function to compute sqrt(cover)/niche-width weighted mean
cNWwmean <- function(indicatorValue, cover, nicheWidth) {
  weights <- sqrt(cover[!is.na(indicatorValue)]) / nicheWidth[!is.na(indicatorValue)]
  indicators <- indicatorValue[!is.na(indicatorValue)]
  weighted.mean(indicators, weights)
}
```


Run aggregation
```{r}
begin<- Sys.time()

aggregatedEva <- eva |> 
  group_by(PlotObservationID) |> 
  summarise(
    numberOfVascularPlantSpecies = n(), 
    
    EIVEresM.sqrt = computeSquareRootWeightedMean(EIVEresM, `Cover %`), 
    EIVEresN.sqrt = computeSquareRootWeightedMean(EIVEresN, `Cover %`), 
    EIVEresR.sqrt = computeSquareRootWeightedMean(EIVEresR, `Cover %`), 
    EIVEresL.sqrt = computeSquareRootWeightedMean(EIVEresL, `Cover %`),
    EIVEresT.sqrt = computeSquareRootWeightedMean(EIVEresT, `Cover %`),
    
    EIVEresM.nw = NWwmean(EIVEresM, EIVEnwM), 
    EIVEresN.nw = NWwmean(EIVEresN, EIVEnwN), 
    EIVEresR.nw = NWwmean(EIVEresR, EIVEnwR), 
    EIVEresL.nw = NWwmean(EIVEresL, EIVEnwL),
    EIVEresT.nw = NWwmean(EIVEresT, EIVEnwT), 

    EIVEresM.cnw = cNWwmean(EIVEresM, `Cover %`, EIVEnwM), 
    EIVEresN.cnw = cNWwmean(EIVEresN, `Cover %`, EIVEnwN), 
    EIVEresR.cnw = cNWwmean(EIVEresR, `Cover %`, EIVEnwR), 
    EIVEresL.cnw = cNWwmean(EIVEresL, `Cover %`, EIVEnwL),
    EIVEresT.cnw = cNWwmean(EIVEresT, `Cover %`, EIVEnwT), 

    EIVEresM = mean(EIVEresM, na.rm = T), 
    EIVEresN = mean(EIVEresN, na.rm = T), 
    EIVEresR = mean(EIVEresR, na.rm = T), 
    EIVEresL = mean(EIVEresL, na.rm = T), 
    EIVEresT = mean(EIVEresT, na.rm = T), 

    DistSeverity.sqrt = computeSquareRootWeightedMean(Disturbance.Severity, `Cover %`), 
    #DistSeverityHerblayer.sqrt = computeSquareRootWeightedMean(Disturbance.Severity.herblayer, `Cover %`),
    DistFrequency.sqrt = computeSquareRootWeightedMean(Disturbance.Frequency, `Cover %`),
    #DistFrequencyHerblayer.sqrt = computeSquareRootWeightedMean(Disturbance.Frequency.herblayer, `Cover %`),
    Grazing.Pressure.sqrt = computeSquareRootWeightedMean(Grazing.Pressure, `Cover %`),
    Mowing.Frequency.sqrt = computeSquareRootWeightedMean(Mowing.Frequency, `Cover %`),
    Soil.Disturbance.sqrt = computeSquareRootWeightedMean(Soil.Disturbance, `Cover %`),
    
    DistSeverity = mean(Disturbance.Severity, na.rm = T),
    #DistSeverityHerblayer = mean(Disturbance.Severity.herblayer, na.rm = T),
    DistFrequency = mean(Disturbance.Frequency, na.rm = T),
    #DistFrequencyHerblayer = mean(Disturbance.Frequency.herblayer, na.rm = T),
    Grazing.Pressure=mean(Grazing.Pressure, na.rm=T),
    Mowing.Frequency= mean(Mowing.Frequency, na.rm=T),
    Soil.Disturbance=mean(Soil.Disturbance, na.rm=T),
    
    # I would not go for this, it is just replicating 1 for the length of the cover values
    # Currently just removed these, as there is no niche width--> it does not really make sense to do it in another way
    #DistSeverity.cnw = cNWwmean(Disturbance.Severity, `Cover %`, rep(1,length(`Cover %`))),
    # DistFrequency.cnw = cNWwmean(Disturbance.Frequency, `Cover %`, rep(1,length(`Cover %`))),
    #Grazing.Pressure.cnw = cNWwmean(Grazing.Pressure, `Cover %`, rep(1,length(`Cover %`))),
    #Mowing.Frequency.cnw = cNWwmean(Mowing.Frequency, `Cover %`, rep(1,length(`Cover %`))),
    #Soil.Disturbance.c,w = cNWwmean(Soil.Disturbance, `Cover %`, rep(1,length(`Cover %`))),
    
    logDistSeverity = mean(log(Disturbance.Severity), na.rm=T),
    logDistFrequency = mean(log(Disturbance.Frequency), na.rm = T),
    logGrazing.Pressure=mean(log(Grazing.Pressure), na.rm=T),
    logMowingFrequency=mean(log(Mowing.Frequency), na.rm=T),
    logSoil.Disturbance=mean(log(Soil.Disturbance), na.rm=T)
    
    # Here two previous option I do not know why this method
    # Nevermind, otherwise you create -inf values when it was 0
    #logDistSeverity = mean(log(Disturbance.Severity + 1/2*min(div$Disturbance.Severity[div$Disturbance.Severity>0])), na.rm = T),
    #logDistFrequency = mean(log(Disturbance.Frequency + 1/2*min(div$Disturbance.Frequency[div$Disturbance.Frequency>0])), na.rm = T)
    )
end<- Sys.time()
round(end-begin)
```


Join the result with the header data:
```{r}
#aggregatedEva2<-read.csv("aggregatedEva.csv")
fullPlotData<- subset(header, select= c(PlotObservationID, Country,Longitude, Latitude, Region, Dataset, `Relevé area (m²)`,`Date of recording`))
fullPlotData <- full_join(fullPlotData, aggregatedEva, by = "PlotObservationID")
names(fullPlotData)[names(fullPlotData) == 'Relevé area (m²)'] <- 'Area'
names(fullPlotData)[names(fullPlotData) == 'Date of recording'] <- 'Date'
```



## 3.2 Filter SR
Check which plots are extremely species rich:
```{r}
# Which plots SR>100
highDiversityPlots <- fullPlotData[fullPlotData$numberOfVascularPlantSpecies > 100,]

# Jurgen plots suspiciously high
highDiversityPlotsToBeRemoved <- c(842839, 843192, 842921) # plots published by Juergen which are for sure incorrect

highDiversityPlots$Dataset<- as.character(highDiversityPlots$Dataset)
# Look at datasets containing the plots with SR> 100
highDiversityDatasets <- unique(highDiversityPlots$Dataset)

# Look when SR is high for more than two plots in a dataset and obtain their observation ID
for(dataset in highDiversityDatasets) {
  # take all plots for a specific dataset
  plotsInDataset <- highDiversityPlots[highDiversityPlots$Dataset == dataset,]
  # take per amount of SR the frequency this specific SR is present
  multiplicityOfRichnessOccurrence <- as.data.frame(table(plotsInDataset$numberOfVascularPlantSpecies))
  # take all times the same SR is present multiple times in a plot
  multiplicityOfRichnessOccurrence <- multiplicityOfRichnessOccurrence[multiplicityOfRichnessOccurrence$Freq >= 2,] # we want to remove only the plots which > 100 species and suspiciously frequent in the database
  for(richness in multiplicityOfRichnessOccurrence$Var1) {
    # take the index of all plots in the dataset with this species richness
    plotsToBeRemoved <- plotsInDataset[plotsInDataset$numberOfVascularPlantSpecies == richness,]
    highDiversityPlotsToBeRemoved <- append(highDiversityPlotsToBeRemoved, plotsToBeRemoved$PlotObservationID)
  }
}
highDiversityPlots[highDiversityPlots$PlotObservationID %in% highDiversityPlotsToBeRemoved,]

numberOfHighDiversityPlotsToBeRemoved <- length(highDiversityPlotsToBeRemoved)

# remove the too high diversiy plots from the dataset
fullPlotData <- fullPlotData[!(fullPlotData$PlotObservationID %in% highDiversityPlotsToBeRemoved),]

# make a new highdiversityplots dataset for all true diverse plots (according to the method)
highDiversityPlots <- fullPlotData[fullPlotData$numberOfVascularPlantSpecies > 100,]
# plot to have an idea how the SR is distributed
# hist(fullPlotData$numberOfVascularPlantSpecies)
# write_csv(highDiversityPlots, "highDiversityPlots.csv")
```

`r numberOfHighDiversityPlotsToBeRemoved` of the plots were removed because they have suspiciously high, non unique richness in the same database or are known to be incorrect.

## 3.3 Filter IV
Filtering out plots for which some of the indicator values could not be estimated:
```{r}
# Cells with NA in fullPlot
fullPlotDataNas <- is.na(fullPlotData)
# Get the plot observations
plotsForWhichNotAllIndicatorValuesWereEstimated <- fullPlotDataNas[,1]
# 9 is number of vascular plants
for(i in 9:dim(fullPlotDataNas)[2]) {
  plotsForWhichNotAllIndicatorValuesWereEstimated <- plotsForWhichNotAllIndicatorValuesWereEstimated | fullPlotDataNas[,i]
}
numberOfPlotsWithMissingIndicatorValues <- sum(plotsForWhichNotAllIndicatorValuesWereEstimated)

# We also test the proportion of species removed to check how much of them are native
test<- eva[eva$PlotObservationID %in% fullPlotData$PlotObservationID[which(plotsForWhichNotAllIndicatorValuesWereEstimated)],]
test<- test[, c("species","irena", "EIVEresM","EIVEresN","EIVEresR","EIVEresL","EIVEresT")]
test<- test |> group_by(species, irena) |> summarise(n=n())
test<- left_join(test, taxonNameCorrections, by=c("irena"="species"))

# percent of natives dropped by dropping site
sum(test$n[(test$statusEurope=="native")], na.rm=T)/sum(test$n)

# percent of natives dropped by dropping sîte
sum(test$n[(test$statusEurope=="neo")], na.rm=T)/sum(test$n)

# percent of natives dropped by dropping site
sum(test$n[(test$statusEurope=="arch")], na.rm=T)/sum(test$n)

# remove the plots without an indicator value
fullPlotData <- fullPlotData[!plotsForWhichNotAllIndicatorValuesWereEstimated,]
```


## 3.4 Filter date
```{r}
fullPlotData$Date<- as.Date(fullPlotData$Date, format = "%d.%m.%Y")
numberOfPlotsWithoutDate<-length(fullPlotData$PlotObservationID[is.na(fullPlotData$Date)])
fullPlotData<- fullPlotData[!is.na(fullPlotData$Date),]
```


Remove all from data
```{r}
# remove the removed plots also from eva, header and aggregated eva
aggregatedEva <- aggregatedEva[aggregatedEva$PlotObservationID %in% fullPlotData$PlotObservationID,]
header <- header[header$PlotObservationID %in% fullPlotData$PlotObservationID,]
eva <- eva[eva$PlotObservationID %in% fullPlotData$PlotObservationID,]
```

`r numberOfPlotsWithMissingIndicatorValues` of the plots were removed because not all indicator values could be estimated.

# 4 PLOT
## 4.1 SR
```{r}
par(mfrow=c(1,1))
boxplot(fullPlotData$numberOfVascularPlantSpecies)
hist(fullPlotData$numberOfVascularPlantSpecies)
# As expected the count data on species richness looks quite skewed. Hence, we will need to use a poisson glm/ gam
```


## 4.2 IVs
```{r}
# Square root
boxplot(fullPlotData$DistSeverity.sqrt)
boxplot(fullPlotData$DistFrequency.sqrt)
boxplot(fullPlotData$Grazing.Pressure.sqrt)
boxplot(fullPlotData$Mowing.Frequency.sqrt)
boxplot(fullPlotData$Soil.Disturbance.sqrt)

hist(fullPlotData$DistSeverity.sqrt)
hist(fullPlotData$DistFrequency.sqrt)
hist(fullPlotData$Grazing.Pressure.sqrt)
hist(fullPlotData$Mowing.Frequency.sqrt)
hist(fullPlotData$Soil.Disturbance.sqrt)

boxplot(fullPlotData$EIVEresM.sqrt)
boxplot(fullPlotData$EIVEresN.sqrt)
boxplot(fullPlotData$EIVEresR.sqrt)
boxplot(fullPlotData$EIVEresL.sqrt)
boxplot(fullPlotData$EIVEresT.sqrt)

# nw
boxplot(fullPlotData$EIVEresM.nw)
boxplot(fullPlotData$EIVEresN.nw)
boxplot(fullPlotData$EIVEresR.nw)
boxplot(fullPlotData$EIVEresL.nw)
boxplot(fullPlotData$EIVEresT.nw)

# cnw
boxplot(fullPlotData$EIVEresM.cnw)
boxplot(fullPlotData$EIVEresN.cnw)
boxplot(fullPlotData$EIVEresR.cnw)
boxplot(fullPlotData$EIVEresL.cnw)
boxplot(fullPlotData$EIVEresT.cnw)

# mean
boxplot(fullPlotData$Grazing.Pressure)
boxplot(fullPlotData$Mowing.Frequency)
boxplot(fullPlotData$Soil.Disturbance)
boxplot(fullPlotData$DistSeverity)
boxplot(fullPlotData$DistFrequency)

hist(fullPlotData$Grazing.Pressure)
hist(fullPlotData$Mowing.Frequency)
hist(fullPlotData$Soil.Disturbance)
hist(fullPlotData$DistSeverity)
hist(fullPlotData$DistFrequency)


boxplot(fullPlotData$EIVEresM) # Looks good
boxplot(fullPlotData$EIVEresN) # Looks good
boxplot(fullPlotData$EIVEresR) # Looks good
boxplot(fullPlotData$EIVEresL) # Looks good
boxplot(fullPlotData$EIVEresT) # Looks good

#Log mean
boxplot(fullPlotData$logMowingFrequency)
boxplot(fullPlotData$logGrazing.Pressure)
boxplot(fullPlotData$logSoil.Disturbance)
boxplot(fullPlotData$logDistSeverity)
boxplot(fullPlotData$logDistFrequency)

hist(fullPlotData$logMowingFrequency)
hist(fullPlotData$logGrazing.Pressure)
hist(fullPlotData$logSoil.Disturbance)
hist(fullPlotData$logDistSeverity)
hist(fullPlotData$logDistFrequency)
```

The distribution of the EIVE predictors look symmetrical. However, the disturbance indicators are heavily skewed. Hence, they need to be transformed. Because there are zeros in the data we choose a root transoformation. Trying different powers we found that the 4th root worked best:

## 4.3 Transform
```{r}
# originally 1/4
fullPlotData$transformedDisturbanceSeverity.sqrt <- fullPlotData$DistSeverity.sqrt^(1/2)
fullPlotData$transformedDisturbanceFrequency.sqrt <- fullPlotData$DistFrequency.sqrt^(1/2)
fullPlotData$transformedDisturbanceSeverity <- fullPlotData$DistSeverity^(1/2)
fullPlotData$transformedDisturbanceFrequency <- fullPlotData$DistFrequency^(1/2)

hist(fullPlotData$transformedDisturbanceSeverity.sqrt)
hist(fullPlotData$DistSeverity.sqrt) # imo even better distributed...
hist(fullPlotData$transformedDisturbanceFrequency.sqrt)
hist(fullPlotData$DistFrequency.sqrt)

hist(fullPlotData$transformedDisturbanceSeverity)
hist(fullPlotData$DistSeverity) # imo even better distributed...
hist(fullPlotData$transformedDisturbanceFrequency)
hist(fullPlotData$DistFrequency)
```


# 5 BASE MODEL
Note that this is not the final Base Model, rather we will use this to check the assumptions made.
```{r}
glm0 <- glm(numberOfVascularPlantSpecies ~ 
                    log(Area) + 
                    EIVEresM + I(EIVEresM^2) + 
                    EIVEresN + I(EIVEresN^2) + 
                    EIVEresR + I(EIVEresR^2) + 
                    EIVEresL + I(EIVEresL^2) + 
                    EIVEresT + I(EIVEresT^2) +
                    DistSeverity + I(DistSeverity^2) +
                    DistFrequency + I(DistFrequency^2)
                  , family=poisson, fullPlotData)

summary(glm0)
plot(glm0)
```

We can see that the residuals of this model are in a reasonable range and hence the model fits reasonably well to the data.
```{r}
dataFromGermany <- fullPlotData[fullPlotData$Region == "Germany",]
dataFromGermany$Dataset <- as.factor(as.character(dataFromGermany$Dataset))
par(mfrow = c(1,1))
boxplot(numberOfVascularPlantSpecies ~ Dataset, data = dataFromGermany)
boxplot(log(fullPlotData$Area))
```

Looking at different datasets from a similar region exhibits quite large differences in terms of species richness. It will most likely make sense to include Dataset as a random factor. The log transformed size of the plots is very symmetrical. This looks good.

# 6 EXPORT
## 6.1 EVA + HEAD
```{r}
# Make sure all plot data is in eva
fullPlotData <- fullPlotData[fullPlotData$PlotObservationID %in% eva$PlotObservationID,]
fullPlotData$Dataset <- as.factor(as.character(fullPlotData$Dataset))
#write_csv(fullPlotData, "fullPlotData_ESy.csv")
 
# Make sure all eva data has a plot 
eva <- eva[eva$PlotObservationID %in% fullPlotData$PlotObservationID,]
fullPlotEva <- eva
#write_csv(eva, "fullPlotEva_ESy.csv")
```




## 6.2 Check neophytes
```{r}
# File for Irena
# Eva
#fullPlotEva2 <- read_csv("fullPlotEva_ESy.csv", show_col_types = FALSE)
eva2<- fullPlotEva[,c("PlotObservationID","species","irena", "Matched concept", "name","source")]
#fullPlotData2<- read_csv("fullPlotData_ESy.csv", show_col_types = FALSE)
fullPlot2<- fullPlotData[,c("PlotObservationID","Region")]

# eva names
eva_names <- unique(eva[, c(2:6)])

# Join and summarise
eva_country<- left_join(eva2, fullPlot2)
species_country<- eva_country |> group_by(Region, species, irena, `Matched concept`, name, source) |> summarize(n=n())

# load neophyte data
neophyte<-readxl::read_excel("species_status_region-VK-IA.xlsx")


# change names to all accepted
neophyte$name <- eva_names$species[match(neophyte$species, eva_names$species)]
neophyte$name[is.na(neophyte$name)]<- eva_names$species[match(neophyte$species[is.na(neophyte$name)], eva_names$irena)]
neophyte$name[is.na(neophyte$name)]<- eva_names$species[match(neophyte$species[is.na(neophyte$name)], eva_names$`Matched concept`)]

# some (1450) species not in dataset now

# some species are not anymore in dataset so we check against original species list
new_names <- unique(new[, c(6,12:13)])
neophyte$name[is.na(neophyte$name)]<- new_names$species[match(neophyte$species[is.na(neophyte$name)], new_names$species)]
neophyte$name[is.na(neophyte$name)]<- new_names$species[match(neophyte$species[is.na(neophyte$name)], new_names$irena)]
neophyte$name[is.na(neophyte$name)]<- new_names$species[match(neophyte$species[is.na(neophyte$name)], new_names$`Matched concept`)]

# check rest
neophyte$species[is.na(neophyte$name)]
# looks fine
colnames(neophyte) <- c("Region","name","FloraVegSpecies","Neophyte","species")

# are there some duplicates
x <- neophyte[(duplicated(neophyte[,c(1,5)])| duplicated(neophyte[,c(1,5)], fromLast=TRUE)),]
x <- x[!(duplicated(x[,c(1,4:5)]) | duplicated(x[,c(1,4:5)], fromLast=TRUE)),]

# check x and change wrong classifications
change <- data.frame(species= c("Quercus rubra", "Gentianella aspera","Salix gmelinii"),
                     status= c("neo", "native", "neo"))
# assign to neophyte
neophyte$Neophyte[neophyte$species %in% change$species] <- change$status[match(neophyte$species[neophyte$species %in% change$species],
                                                                           change$species)]

# we check again whether our change was successful
x <- neophyte[(duplicated(neophyte[,c(1,5)])| duplicated(neophyte[,c(1,5)], fromLast=TRUE)),]
x <- x[!(duplicated(x[,c(1,4:5)]) | duplicated(x[,c(1,4:5)], fromLast=TRUE)),]

# we remove all duplicates to be able to join with species_country without many-to-many relationships
neophyte <- neophyte[!duplicated(neophyte[,c(1,5)]),]

# join
species_country <- full_join(species_country, neophyte, by= c("species"="species", "Region"="Region"))
species_country[is.na(species_country$Neophyte),] <- left_join(species_country[is.na(species_country$Neophyte), -c(6:8)], neophyte,
                                                               by= c("irena"="species", "Region"="Region"))
species_country[is.na(species_country$Neophyte),] <- left_join(species_country[is.na(species_country$Neophyte), -c(6:8)], neophyte,
                                                               by= c("Matched concept"="species", "Region"="Region"))

# check NAs
unique(species_country$species[is.na(species_country$Neophyte)])


# not
not <- species_country[is.na(species_country$Neophyte),]
not<- not[!duplicated(not$species),]

# save
#write_csv(neophyte, "neophyte_euro.csv")
```



```{r}
#write_csv(species_country,"country_species_euro.csv")
#write_csv(species_country,"country_species_euro_cover.csv")
```



# 8 LATER
```{r}
test<- read.csv("fullPlotData.csv")

hist(test$DistSeverity)
hist(sqrt(sqrt(test$DistFrequency)))
hist((test$Soil.Disturbance.sqrt))

sum(taxonNameCorrections$statusEurope=="native")
sum(taxonNameCorrections$statusEurope=="neo")
sum(taxonNameCorrections$statusEurope=="arch")
unique(taxonNameCorrections$species[taxonNameCorrections$statusEurope=="arch"])
```




# 9 To Do
TODO: how to handle niche width and number of original EIVs in EIVE to improve the estimation of the EIVE value in EVA?
TODO: also calculate richness without neophytes?
