---
title: "Data preparation"
subtitle: "based on the work of Christian Ledergerber"
author: "Willem Goossens"
date: "`r Sys.Date()`"
output: html_document
---
# 1 LOAD
## 1.1 prepare
We first clean the environment
```{r, echo=T}
rm(list=ls())
```

We load the required libraries
```{r, warning=F, message=F}
library(readr)
library(tidyr)
library(dplyr)
library(magrittr)
library(ggplot2)
library(AER)
library(mgcv)
library(modEvA)
library(doParallel)
library(arsenal)
library(pracma)
```


## 1.2 Eva Data
We load the data
```{r , message=FALSE, warning=FALSE}
fast <- F
if(fast) {
  eva <- read_delim("../EVA Data/onePromilleEva.csv", "\t")
} else {
  eva <- read_delim("../EVA Data/171_NeophyteInvasions20230216_notJUICE_species.csv", "\t")
}
```

We remove the rows without observations.
```{r}
# Count the number of rows with NA values
numberOfRowsWithoutPlotID <- sum(is.na(eva$PlotObservationID))
# Check rows with NA
# eva[which(is.na(eva$PlotObservationID)),]
# Filter out all rows which don't have a plot ID
eva <- eva[!is.na(eva$PlotObservationID),]
# Count number of plots in eva before data removal
originalPlotNumberEva<- length(unique(eva$PlotObservationID))
```


We update the taxa data
```{r, warning=F, message=FALSE}
# Update taxon group for some species where it was specified incorrectly
taxonGroupCorrections <- read_csv("../Intermediate Data/taxa_taxon_group_corrections.csv")

# What is the location of the species in eva that are specified incorrectly
index <- eva$`Matched concept` %in% taxonGroupCorrections$Matched.concept

# Change to correct for each species
eva$`Taxon group`[index] <- taxonGroupCorrections$NewTaxonGroup[match(eva$`Matched concept`[index], taxonGroupCorrections$Matched.concept)]


# Update taxon group for species that did not have one in EVA
taxonGroupAssignments <- read_csv("../Intermediate Data/taxa_taxon_group_assignments.csv")
index <- eva$`Matched concept` %in% taxonGroupAssignments$Matched.concept
eva$`Taxon group`[index] <- taxonGroupAssignments$TaxonGroup[match(eva$`Matched concept`[index], taxonGroupAssignments$Matched.concept)]


# Some taxon names seem incorrect
taxonNameCorrections <- read_csv("../Neophyte Assignments/UniqueTaxaEurope-2023-04-23.csv")

# give the species name from taxon name corrections to eva in the species column
# to lower makes sure all data is written without capitals
# match gives vector with position of argument eva in taxonNameCorrections, and does this for the total length of eva
eva$species <- taxonNameCorrections$species[match(tolower(eva$`Matched concept`), tolower(taxonNameCorrections$Matched.concept))]

# some data of species is.na, we assign for these the values of the matched concept
eva$species[is.na(eva$species)] <- eva$`Matched concept`[is.na(eva$species)] 

# fix problem with plant not present in neophyte file from irena (only a handful of plant observations in EVA)
# In file Irena some write 'exclude'
```

We only keep vascular plants and remove the columns in which this data is designated.
```{r}
eva <- eva[eva$`Taxon group` == "Vascular plant",!names(eva) %in% c("Taxon group", "Taxon group ID")]
```



## 1.3 Header Data
Read in the header information. Look at and remove plots for which:

-   Area is NA or smaller than 0
-   Area is larger than 1000 m²
-   The longitude or latitude data is not known
-   The plot is not assigned to a region
-   The plot only contains presence/absence data

```{r, message=F, warning=F}
header <- read_delim("../EVA Data/171_NeophyteInvasions20230216_notJUICE_header.csv", "\t")
totalNumberOfPlots <- length(header$PlotObservationID)

# Plot sizes too small/ inexistent
plotsWithoutPlotSize <- is.na(header$`Relevé area (m²)`) | header$`Relevé area (m²)` <= 0
numberOfPlotsWithoutPlotSize <- sum(plotsWithoutPlotSize)

# Plot sizes too large (https://onlinelibrary.wiley.com/doi/full/10.1002/ece3.8965)
tooLargePlots <- header$`Relevé area (m²)` > 1000
numberOfTooLargePlots<- sum(tooLargePlots, na.rm=T)

# Plots without coordinates
plotsWithoutLocation <- is.na(header$Latitude) | is.na(header$Longitude)
numberOfPlotsWithoutLocation <- sum(plotsWithoutLocation)

# Check whether the amount of observation plots correspond
# This is the data made in 3_Region_check (here we also removed all data without coordinates)
plotsRegionAssignments <- read_csv("../Intermediate Data/plot_to_region_assignment.csv")
# Error message if the two are not the same
if( sum(header$PlotObservationID[!plotsWithoutLocation] != plotsRegionAssignments$PlotObservationID) > 0) {
  message("Error: plotsRegionAssignments expected to contain the same plots as contained in header data.")
}

# Count number of plots unassigned
# create logical vector of header length
plotsWithoutRegionAssignment <- vector(mode = "logical", length = length(header$PlotObservationID))
# make true when the plot has no region, taking into consideration that some plots have no coordinates
plotsWithoutRegionAssignment[!plotsWithoutLocation] <- is.na(plotsRegionAssignments$Region)
numberOfPlotsWithoutRegionAssignment = sum(plotsWithoutRegionAssignment)

# Remove only Presence/ Absence data and NA data
namesForPresenceAbsence <- c("Presence/Absence", "Presentie/Absentie", NA)
# logical vector with length header 
plotsWithPresenceAbsenceOnly <- header$`Cover abundance scale` %in% namesForPresenceAbsence
numberOfPlotsWithoutCoverInformation <- sum(plotsWithPresenceAbsenceOnly)

# sum all plots to be removed
allPlotsToBeRemoved <- plotsWithoutPlotSize | tooLargePlots | plotsWithoutLocation | plotsWithPresenceAbsenceOnly | plotsWithoutRegionAssignment
totalNumberRemoved <- sum(allPlotsToBeRemoved)
```

`r numberOfPlotsWithoutPlotSize` of the plots do not contain a size, `r numberOfTooLargePlots` were larger than 1000m² and therefore most likely no plots, `r numberOfPlotsWithoutLocation` of the plots do not have a location, `r numberOfPlotsWithoutRegionAssignment` cannot be assigned to one of the neophyte regions and `r numberOfPlotsWithoutCoverInformation` of the plots do not contain cover data. All these plots (`r totalNumberRemoved`) are removed:
```{r}
header <- header[!allPlotsToBeRemoved,]
```

We also add the region to the data for analysis and change the region and dataset to a factor.
```{r}
header <- left_join(header, plotsRegionAssignments, by = "PlotObservationID")
header$Region <- as.factor(header$Region)
header$Dataset <- as.factor(header$Dataset)
```

Finally, we will keep only the plots that are still available in both Eva and Header
```{r}
plotsInEvaAndHeader <- intersect(eva$PlotObservationID, header$PlotObservationID)
eva <- eva[eva$PlotObservationID %in% plotsInEvaAndHeader,]
header <- header[header$PlotObservationID %in% plotsInEvaAndHeader,]
```
After filtering `r length(header$PlotObservationID)` plots remain.

# 2 INDICATORS
## 2.1 Eive
Reading in the EIVE data and explore data by boxplotting the moisture (M), nitrogen (N), pH (R), light (L) and temperature (T) variables.
```{r, message=F, fig.show = "hide"}
# 08 contains the indicator values for position and width
eive <- read_delim("../EIVE Data/EIVE_Paper_1.0_SM_08.csv", ",")
# data contains n --> number of sources, nw--> niche width and ''--> value

par(mfrow = c(1,1))
boxplot(eive$`EIVEres-M`, xlab="M") # outliers above
boxplot(eive$`EIVEres-N`, xlab="N") # little outliers
boxplot(eive$`EIVEres-R`, xlab="R") # outliers below
boxplot(eive$`EIVEres-L`, xlab="L") # outliers below
boxplot(eive$`EIVEres-T`, xlab="T") # little outliers
par(mfrow=c(1,1))
```

The EIVE values are OK balanced with some outliers. No extreme skewness to be expected for the average indicator values at the plot level.

Extend eva with columns from EIVE.
```{r, fig.show = "hide"}
# match gives position of species in eva in eive
# positions
eva$EIVEresM <- eive$`EIVEres-M`[match(eva$species, eive$TaxonConcept)]
eva$EIVEresN <- eive$`EIVEres-N`[match(eva$species, eive$TaxonConcept)]
eva$EIVEresR <- eive$`EIVEres-R`[match(eva$species, eive$TaxonConcept)]
eva$EIVEresL <- eive$`EIVEres-L`[match(eva$species, eive$TaxonConcept)]
eva$EIVEresT <- eive$`EIVEres-T`[match(eva$species, eive$TaxonConcept)]

# niche widths
eva$EIVEnwM <- eive$`EIVEres-M.nw3`[match(eva$species, eive$TaxonConcept)]
eva$EIVEnwN <- eive$`EIVEres-N.nw3`[match(eva$species, eive$TaxonConcept)]
eva$EIVEnwR <- eive$`EIVEres-R.nw3`[match(eva$species, eive$TaxonConcept)]
eva$EIVEnwL <- eive$`EIVEres-L.nw3`[match(eva$species, eive$TaxonConcept)]
eva$EIVEnwT <- eive$`EIVEres-T.nw3`[match(eva$species, eive$TaxonConcept)]

# Look at number of observations not in EIVE
numberOfPlantsInEvaFoundInEive <- sum(!(is.na(eva$EIVEresM) | 
                                              is.na(eva$EIVEresN) | 
                                              is.na(eva$EIVEresR) | 
                                              is.na(eva$EIVEresL) | 
                                              is.na(eva$EIVEresT)))
percentEvaInEive<- numberOfPlantsInEvaFoundInEive/length(eva$PlotObservationID)
```


`r numberOfPlantsInEvaFoundInEive` of the `r length(eva$PlotObservationID)` plant observations in Eva have indicator values in EIVE.


Look at unique species to see whether neophytes are not with less relative representatives
This has to be performed with old data, since new data from Irena (January 2024) is only on the full plot data (which is made later in this file, after removing some plots etc)
```{r}
test<- eva[, c("species", "EIVEresM","EIVEresN","EIVEresR","EIVEresL","EIVEresT")]
test<- test[!duplicated(test$species),]
test<- left_join(test, taxonNameCorrections, by="species")

test$statusEurope<- as.character(test$statusEurope)
# percent of natives without data
length(test$species[(test$statusEurope=="native") & (is.na(test$EIVEresL)| is.na(test$EIVEresM)|is.na(test$EIVEresN)|is.na(test$EIVEresR)|is.na(test$EIVEresT))])/length(test$species[test$statusEurope=="native"])

# percent of neophytes without data
length(test$species[(test$statusEurope=="neo") & (is.na(test$EIVEresL)| is.na(test$EIVEresM)|is.na(test$EIVEresN)|is.na(test$EIVEresR)|is.na(test$EIVEresT))])/length(test$species[test$statusEurope=="neo"])

# percent of archeotypes without data
length(test$species[(test$statusEurope=="arch") & (is.na(test$EIVEresL)| is.na(test$EIVEresM)|is.na(test$EIVEresN)|is.na(test$EIVEresR)|is.na(test$EIVEresT))])/length(test$species[test$statusEurope=="arch"])
```


## 2.2 Div
Reading in the disturbance indicator values en plotting severity and frequency.
```{r, messagge=F, warning=F, message=F, fig.show = "hide"}
div <- read_delim("../Disturbance Data/disturbance_indicator_values.csv", ",")

par(mfrow = c(1,1))
# Relatively balanced
boxplot(div$Disturbance.Severity, xlab="Severity")
boxplot(div$Disturbance.Frequency, xlab="Frequency")

# more skewed (check with hist)
boxplot(div$Mowing.Frequency, xlab="Mowing fr")
hist(div$Mowing.Frequency, xlab="Mowing fr")

# check others
boxplot(div$Grazing.Pressure, xlab="Grazing Pr")
boxplot(div$Soil.Disturbance, xlab="Soil dist")

# oke balanced still
hist(div$Grazing.Pressure, xlab="Grazing Pr")
hist(nthroot(div$Soil.Disturbance, 1), xlab="Soil dist")
```


Extend eva with columns from disturbance indicator values:
```{r}
eva$Disturbance.Severity <- div$Disturbance.Severity[match(eva$species, div$species)]
eva$Disturbance.Severity.herblayer <- div$Disturbance.Severity.herblayer[match(eva$species, div$species)]
eva$Disturbance.Frequency <- div$Disturbance.Frequency[match(eva$species, div$species)]
eva$Disturbance.Frequency.herblayer <- div$Disturbance.Frequency.herblayer[match(eva$species, div$species)]
eva$Grazing.Pressure <- div$Grazing.Pressure[match(eva$species, div$species)]
eva$Mowing.Frequency <- div$Mowing.Frequency[match(eva$species, div$species)]
eva$Soil.Disturbance <- div$Soil.Disturbance[match(eva$species, div$species)]

numberOfPlantsInEvaFoundInDiv <- sum(!is.na(eva$Disturbance.Severity))
percentEvaInDiv<- numberOfPlantsInEvaFoundInDiv/length(eva$Disturbance.Severity)
```

`r numberOfPlantsInEvaFoundInDiv` of the `r length(eva$PlotObservationID)` plant observations in Eva have disturbance indicator value.


Look at unique species to see whether neophytes are not with less relative representatives
```{r}
test<- eva[, c("species", "Disturbance.Severity")]
test<- test[!duplicated(test$species),]
test<- left_join(test, taxonNameCorrections, by="species")

test$statusEurope<- as.character(test$statusEurope)
# percent of natives without data
length(test$species[(test$statusEurope=="native") & (is.na(test$Disturbance.Severity))])/length(test$species[test$statusEurope=="native"])

# percent of neophytes without data
length(test$species[(test$statusEurope=="neo") & (is.na(test$Disturbance.Severity))])/length(test$species[test$statusEurope=="neo"])

# percent of archeotypes without data
length(test$species[(test$statusEurope=="arch") & (is.na(test$Disturbance.Severity))])/length(test$species[test$statusEurope=="arch"])
```


# 3 ANALYSIS
## 3.1 Aggregate
Aggregating EVA (#plant per plot and average indicator values) and calculating all kinds of weighting methods for the Eive values.

We have only four options (first three are weighted means)
-   square root of coverage* IV
-   1/niche width * IV
-   square root of coverage* 1/niche width * IV
-   normal mean IV
Following Scherrer et al (2019), Kafer et al (2004) and Descombes et al (2020), the mean indicator value is best correlated with reality but criticized by Tolygesi (2014) 
Following Saatkamp et al (2022), 1/ niche width very good

```{r}
# Function to compute the square root of coverage weighted indicator value 
# Calculate the weight for every species in the plot, then take the indicator value and finally compute the weighted mean
computeSquareRootWeightedMean <- function(indicatorValue, coverage) {
  weights <- sqrt(coverage[!is.na(indicatorValue)])
  indicators <- indicatorValue[!is.na(indicatorValue)]
  weighted.mean(indicators, weights)
}

# Function to compute 1/niche-width weighted mean
NWwmean <- function(indicatorValue, nicheWidth) {
  weights <- 1 / nicheWidth[!is.na(indicatorValue)]
  indicators <- indicatorValue[!is.na(indicatorValue)]
  weighted.mean(indicators, weights)
}

# Function to compute sqrt(cover)/niche-width weighted mean
cNWwmean <- function(indicatorValue, cover, nicheWidth) {
  weights <- sqrt(cover[!is.na(indicatorValue)]) / nicheWidth[!is.na(indicatorValue)]
  indicators <- indicatorValue[!is.na(indicatorValue)]
  weighted.mean(indicators, weights)
}
begin<- Sys.time()
aggregatedEva <- eva |> 
  group_by(PlotObservationID) |> 
  summarise(
    numberOfVascularPlantSpecies = n(), 
    
    EIVEresM.sqrt = computeSquareRootWeightedMean(EIVEresM, `Cover %`), 
    EIVEresN.sqrt = computeSquareRootWeightedMean(EIVEresN, `Cover %`), 
    EIVEresR.sqrt = computeSquareRootWeightedMean(EIVEresR, `Cover %`), 
    EIVEresL.sqrt = computeSquareRootWeightedMean(EIVEresL, `Cover %`),
    EIVEresT.sqrt = computeSquareRootWeightedMean(EIVEresT, `Cover %`),
    
    EIVEresM.nw = NWwmean(EIVEresM, EIVEnwM), 
    EIVEresN.nw = NWwmean(EIVEresN, EIVEnwN), 
    EIVEresR.nw = NWwmean(EIVEresR, EIVEnwR), 
    EIVEresL.nw = NWwmean(EIVEresL, EIVEnwL),
    EIVEresT.nw = NWwmean(EIVEresT, EIVEnwT), 

    EIVEresM.cnw = cNWwmean(EIVEresM, `Cover %`, EIVEnwM), 
    EIVEresN.cnw = cNWwmean(EIVEresN, `Cover %`, EIVEnwN), 
    EIVEresR.cnw = cNWwmean(EIVEresR, `Cover %`, EIVEnwR), 
    EIVEresL.cnw = cNWwmean(EIVEresL, `Cover %`, EIVEnwL),
    EIVEresT.cnw = cNWwmean(EIVEresT, `Cover %`, EIVEnwT), 

    EIVEresM = mean(EIVEresM, na.rm = T), 
    EIVEresN = mean(EIVEresN, na.rm = T), 
    EIVEresR = mean(EIVEresR, na.rm = T), 
    EIVEresL = mean(EIVEresL, na.rm = T), 
    EIVEresT = mean(EIVEresT, na.rm = T), 

    DistSeverity.sqrt = computeSquareRootWeightedMean(Disturbance.Severity, `Cover %`), 
    #DistSeverityHerblayer.sqrt = computeSquareRootWeightedMean(Disturbance.Severity.herblayer, `Cover %`),
    DistFrequency.sqrt = computeSquareRootWeightedMean(Disturbance.Frequency, `Cover %`),
    #DistFrequencyHerblayer.sqrt = computeSquareRootWeightedMean(Disturbance.Frequency.herblayer, `Cover %`),
    Grazing.Pressure.sqrt = computeSquareRootWeightedMean(Grazing.Pressure, `Cover %`),
    Mowing.Frequency.sqrt = computeSquareRootWeightedMean(Mowing.Frequency, `Cover %`),
    Soil.Disturbance.sqrt = computeSquareRootWeightedMean(Soil.Disturbance, `Cover %`),
    
    DistSeverity = mean(Disturbance.Severity, na.rm = T),
    #DistSeverityHerblayer = mean(Disturbance.Severity.herblayer, na.rm = T),
    DistFrequency = mean(Disturbance.Frequency, na.rm = T),
    #DistFrequencyHerblayer = mean(Disturbance.Frequency.herblayer, na.rm = T),
    Grazing.Pressure=mean(Grazing.Pressure, na.rm=T),
    Mowing.Frequency= mean(Mowing.Frequency, na.rm=T),
    Soil.Disturbance=mean(Soil.Disturbance, na.rm=T),
    
    # I would not go for this, it is just replicating 1 for the length of the cover values
    # Currently just removed these, as there is no niche width--> it does not really make sense to do it in another way
    #DistSeverity.cnw = cNWwmean(Disturbance.Severity, `Cover %`, rep(1,length(`Cover %`))),
    # DistFrequency.cnw = cNWwmean(Disturbance.Frequency, `Cover %`, rep(1,length(`Cover %`))),
    #Grazing.Pressure.cnw = cNWwmean(Grazing.Pressure, `Cover %`, rep(1,length(`Cover %`))),
    #Mowing.Frequency.cnw = cNWwmean(Mowing.Frequency, `Cover %`, rep(1,length(`Cover %`))),
    #Soil.Disturbance.c,w = cNWwmean(Soil.Disturbance, `Cover %`, rep(1,length(`Cover %`))),
    
    logDistSeverity = mean(log(Disturbance.Severity), na.rm=T),
    logDistFrequency = mean(log(Disturbance.Frequency), na.rm = T),
    logGrazing.Pressure=mean(log(Grazing.Pressure), na.rm=T),
    logMowingFrequency=mean(log(Mowing.Frequency), na.rm=T),
    logSoil.Disturbance=mean(log(Soil.Disturbance), na.rm=T)
    
    # Here two previous option I do not know why this method
    # Nevermind, otherwise you create -inf values when it was 0
    #logDistSeverity = mean(log(Disturbance.Severity + 1/2*min(div$Disturbance.Severity[div$Disturbance.Severity>0])), na.rm = T),
    #logDistFrequency = mean(log(Disturbance.Frequency + 1/2*min(div$Disturbance.Frequency[div$Disturbance.Frequency>0])), na.rm = T)
    )
end<- Sys.time()
round(end-begin)

#write_csv(aggregatedEva, "aggregatedEva.csv")
```


Join the result with the header data:
```{r}
aggregatedEva2<-read.csv("aggregatedEva.csv")
fullPlotData<- subset(header, select= c(PlotObservationID, Country,Longitude, Latitude, Region, Dataset, `Relevé area (m²)`,`Date of recording`))
fullPlotData <- full_join(fullPlotData, aggregatedEva2, by = "PlotObservationID")
names(fullPlotData)[names(fullPlotData) == 'Relevé area (m²)'] <- 'Area'
names(fullPlotData)[names(fullPlotData) == 'Date of recording'] <- 'Date'
```



## 3.2 Filter SR
Check which plots are extremely species rich:
```{r}
# Which plots SR>100
highDiversityPlots <- fullPlotData[fullPlotData$numberOfVascularPlantSpecies > 100,]

# Jurgen plots suspiciously high
highDiversityPlotsToBeRemoved <- c(842839, 843192, 842921) # plots published by Juergen which are for sure incorrect

# Look at datasets containing the plots with SR> 100
highDiversityDatasets <- unique(highDiversityPlots$Dataset)

# Look when SR is high for more than two plots in a dataset and obtain their observation ID
for(dataset in highDiversityDatasets) {
  # take all plots for a specific dataset
  plotsInDataset <- highDiversityPlots[highDiversityPlots$Dataset == dataset,]
  # take per amount of SR the frequency this specific SR is present
  multiplicityOfRichnessOccurrence <- as.data.frame(table(plotsInDataset$numberOfVascularPlantSpecies))
  # take all times the same SR is present multiple times in a plot
  multiplicityOfRichnessOccurrence <- multiplicityOfRichnessOccurrence[multiplicityOfRichnessOccurrence$Freq >= 2,] # we want to remove only the plots which > 100 species and suspiciously frequent in the database
  for(richness in multiplicityOfRichnessOccurrence$Var1) {
    # take the index of all plots in the dataset with this species richness
    plotsToBeRemoved <- plotsInDataset[plotsInDataset$numberOfVascularPlantSpecies == richness,]
    highDiversityPlotsToBeRemoved <- append(highDiversityPlotsToBeRemoved, plotsToBeRemoved$PlotObservationID)
  }
}


numberOfHighDiversityPlotsToBeRemoved <- length(highDiversityPlotsToBeRemoved)

# remove the too high diversiy plots from the dataset
fullPlotData <- fullPlotData[!(fullPlotData$PlotObservationID %in% highDiversityPlotsToBeRemoved),]

# make a new highdiversityplots dataset for all true diverse plots (according to the method)
highDiversityPlots <- fullPlotData[fullPlotData$numberOfVascularPlantSpecies > 100,]
# plot to have an idea how the SR is distributed
# hist(fullPlotData$numberOfVascularPlantSpecies)
#write_csv(highDiversityPlots, "highDiversityPlots.csv")
```

`r numberOfHighDiversityPlotsToBeRemoved` of the plots were removed because they have suspiciously high, non unique richness in the same database or are known to be incorrect.

## 3.3 Filter IV
Filtering out plots for which some of the indicator values could not be estimated:
```{r}
# Cells with NA in fullPlot
fullPlotDataNas <- is.na(fullPlotData)
# Get the plot observations
plotsForWhichNotAllIndicatorValuesWereEstimated <- fullPlotDataNas[,1]
# 9 is number of vascular plants
for(i in 9:dim(fullPlotDataNas)[2]) {
  plotsForWhichNotAllIndicatorValuesWereEstimated <- plotsForWhichNotAllIndicatorValuesWereEstimated | fullPlotDataNas[,i]
}
numberOfPlotsWithMissingIndicatorValues <- sum(plotsForWhichNotAllIndicatorValuesWereEstimated)

# We also test the proportion of species removed to check how much of them are native
test<- eva[eva$PlotObservationID %in% fullPlotData$PlotObservationID[which(plotsForWhichNotAllIndicatorValuesWereEstimated)],]
test<- test[, c("species", "EIVEresM","EIVEresN","EIVEresR","EIVEresL","EIVEresT")]
test<- test |> group_by(species) |> summarise(n=n())
test<- left_join(test, taxonNameCorrections, by="species")

# percent of natives dropped by dropping site
sum(test$n[(test$statusEurope=="native")])/sum(test$n)

# percent of natives dropped by dropping sîte
sum(test$n[(test$statusEurope=="neo")])/sum(test$n)

# percent of natives dropped by dropping site
sum(test$n[(test$statusEurope=="arch")])/sum(test$n)

# remove the plots without an indicator value
fullPlotData <- fullPlotData[!plotsForWhichNotAllIndicatorValuesWereEstimated,]
```


## 3.4 Filter date
```{r}
numberOfPlotsWithoutDate<-length(fullPlotData$PlotObservationID[is.na(fullPlotData$Date)])
fullPlotData<- fullPlotData[!is.na(fullPlotData$Date),]
```



Remove all from data
```{r}
# remove the removed plots also from eva, header and aggregated eva
aggregatedEva <- aggregatedEva[aggregatedEva$PlotObservationID %in% fullPlotData$PlotObservationID,]
header <- header[header$PlotObservationID %in% fullPlotData$PlotObservationID,]
eva <- eva[eva$PlotObservationID %in% fullPlotData$PlotObservationID,]
```

`r numberOfPlotsWithMissingIndicatorValues` of the plots were removed because not all indicator values could be estimated.

# 4 PLOT
## 4.1 SR
```{r}
par(mfrow=c(1,1))
boxplot(fullPlotData$numberOfVascularPlantSpecies)
hist(fullPlotData$numberOfVascularPlantSpecies)
```


## 4.2 IVs
As expected the count data on species richness looks quite skewed. Hence, we will need to use a poisson glm/ gam
```{r}
# Square root
boxplot(fullPlotData$DistSeverity.sqrt)
boxplot(fullPlotData$DistFrequency.sqrt)
boxplot(fullPlotData$Grazing.Pressure.sqrt)
boxplot(fullPlotData$Mowing.Frequency.sqrt)
boxplot(fullPlotData$Soil.Disturbance.sqrt)

hist(fullPlotData$DistSeverity.sqrt)
hist(fullPlotData$DistFrequency.sqrt)
hist(fullPlotData$Grazing.Pressure.sqrt)
hist(fullPlotData$Mowing.Frequency.sqrt)
hist(fullPlotData$Soil.Disturbance.sqrt)

boxplot(fullPlotData$EIVEresM.sqrt)
boxplot(fullPlotData$EIVEresN.sqrt)
boxplot(fullPlotData$EIVEresR.sqrt)
boxplot(fullPlotData$EIVEresL.sqrt)
boxplot(fullPlotData$EIVEresT.sqrt)

# nw
boxplot(fullPlotData$EIVEresM.nw)
boxplot(fullPlotData$EIVEresN.nw)
boxplot(fullPlotData$EIVEresR.nw)
boxplot(fullPlotData$EIVEresL.nw)
boxplot(fullPlotData$EIVEresT.nw)

# cnw
boxplot(fullPlotData$EIVEresM.cnw)
boxplot(fullPlotData$EIVEresN.cnw)
boxplot(fullPlotData$EIVEresR.cnw)
boxplot(fullPlotData$EIVEresL.cnw)
boxplot(fullPlotData$EIVEresT.cnw)

# mean
boxplot(fullPlotData$Grazing.Pressure)
boxplot(fullPlotData$Mowing.Frequency)
boxplot(fullPlotData$Soil.Disturbance)
boxplot(fullPlotData$DistSeverity)
boxplot(fullPlotData$DistFrequency)

hist(fullPlotData$Grazing.Pressure)
hist(fullPlotData$Mowing.Frequency)
hist(fullPlotData$Soil.Disturbance)
hist(fullPlotData$DistSeverity)
hist(fullPlotData$DistFrequency)


boxplot(fullPlotData$EIVEresM) # Looks good
boxplot(fullPlotData$EIVEresN) # Looks good
boxplot(fullPlotData$EIVEresR) # Looks good
boxplot(fullPlotData$EIVEresL) # Looks good
boxplot(fullPlotData$EIVEresT) # Looks good

#Log mean
boxplot(fullPlotData$logMowingFrequency)
boxplot(fullPlotData$logGrazing.Pressure)
boxplot(fullPlotData$logSoil.Disturbance)
boxplot(fullPlotData$logDistSeverity)
boxplot(fullPlotData$logDistFrequency)

hist(fullPlotData$logMowingFrequency)
hist(fullPlotData$logGrazing.Pressure)
hist(fullPlotData$logSoil.Disturbance)
hist(fullPlotData$logDistSeverity)
hist(fullPlotData$logDistFrequency)
```

The distribution of the EIVE predictors look symmetrical. However, the disturbance indicators are heavily skewed. Hence, they need to be transformed. Because there are zeros in the data we choose a root transoformation. Trying different powers we found that the 4th root worked best:

## 4.3 Transform
```{r}
# originally 1/4
fullPlotData$transformedDisturbanceSeverity.sqrt <- fullPlotData$DistSeverity.sqrt^(1/2)
fullPlotData$transformedDisturbanceFrequency.sqrt <- fullPlotData$DistFrequency.sqrt^(1/2)
fullPlotData$transformedDisturbanceSeverity <- fullPlotData$DistSeverity^(1/2)
fullPlotData$transformedDisturbanceFrequency <- fullPlotData$DistFrequency^(1/2)

hist(fullPlotData$transformedDisturbanceSeverity.sqrt)
hist(fullPlotData$DistSeverity.sqrt) # imo even better distributed...
hist(fullPlotData$transformedDisturbanceFrequency.sqrt)
hist(fullPlotData$DistFrequency.sqrt)

hist(fullPlotData$transformedDisturbanceSeverity)
hist(fullPlotData$DistSeverity) # imo even better distributed...
hist(fullPlotData$transformedDisturbanceFrequency)
hist(fullPlotData$DistFrequency)
```


After transformation with log(x + eps) the disturbance indicator values are much better centered. However, the transformation function is a bit arbitrary and there are still outliers which cause difficulties with analysis as can be seen by fitting a straight forward model:

# 5 BASE MODEL
Note that this is not the final Base Model, rather we will use this to check the assumptions made.
```{r}
glm0 <- glm(numberOfVascularPlantSpecies ~ 
                    log(Area) + 
                    EIVEresM + I(EIVEresM^2) + 
                    EIVEresN + I(EIVEresN^2) + 
                    EIVEresR + I(EIVEresR^2) + 
                    EIVEresL + I(EIVEresL^2) + 
                    EIVEresT + I(EIVEresT^2) +
                    DistSeverity + I(DistSeverity^2) +
                    DistFrequency + I(DistFrequency^2)
                  , family=poisson, fullPlotData)

summary(glm0)
plot(glm0)
```

We can see that the residuals of this model are in a reasonable range and hence the model fits reasonably well to the data.


```{r}
dataFromGermany <- fullPlotData[fullPlotData$Region == "Germany",]
dataFromGermany$Dataset <- as.factor(as.character(dataFromGermany$Dataset))
par(mfrow = c(1,1))
boxplot(numberOfVascularPlantSpecies ~ Dataset, data = dataFromGermany)
boxplot(log(fullPlotData$Area))
```

Looking at different datasets from a similar region exhibits quite large differences in terms of species richness. It will most likely make sense to include Dataset as a random factor. The log transformed size of the plots is very symmetrical. This looks good.

# 6 EXPORT
## 6.1 EVA + HEAD
```{r}
# Make sure all plot data is in eva
fullPlotData <- fullPlotData[fullPlotData$PlotObservationID %in% eva$PlotObservationID,]
fullPlotData$Dataset <- as.factor(as.character(fullPlotData$Dataset))
#write_csv(fullPlotData, "fullPlotData.csv")

# Make sure all eva data has a plot 
eva <- eva[eva$PlotObservationID %in% fullPlotData$PlotObservationID,]
#write_csv(eva, "fullPlotEva.csv")
```


## 6.2 Check neophytes
```{r}
# File for Irena
# Eva
eva2<- eva[,c("PlotObservationID","species")]
# Header
fullPlot2<- fullPlotData[,c("PlotObservationID","Region")]
# Join and summarise
eva_country<- left_join(eva2, fullPlot2)
species_country<- eva_country |> group_by(Region) |> summarise(species= unique(species))

#write.csv(species_country,"country_species.csv")
```


# 7 FREQUENCY
## 7.1 Analysis
This has become wrong, as we have some intra-european neophytes that are present in one part and not in another 
Compute which species occurs how often in eva:
```{r}
# For speed optimization we extract only the necessary information from EVA
reducedEva <- eva |> select(PlotObservationID, species, `Cover %`)

uniqueSpecies <- unique(reducedEva$species)

# Empty dataset
plotsPerSpecies <- data.frame(names = character(), numberOfPlots = integer())

# Prepare parallel
parallel::detectCores()
n.cores <- parallel::detectCores() - 2
my.cluster <- parallel::makeCluster(
  n.cores, 
  type = "PSOCK"
)
print(my.cluster)
doParallel::registerDoParallel(cl = my.cluster)
foreach::getDoParRegistered()
foreach::getDoParWorkers()


# Count in how many plots a species occurs
begin<- Sys.time()
plotsPerSpecies<-foreach(i= 1:length(uniqueSpecies), .combine='rbind', .packages=c("dplyr","mgcv")) %dopar% {
  tmp <- reducedEva$PlotObservationID[reducedEva$species == uniqueSpecies[i]]
  names=uniqueSpecies[i]
  numberOfPlots= length(unique(tmp))
  plotsPerSpecies[i,]<- c(names, numberOfPlots)
}
plotsPerSpecies<- as.data.frame(plotsPerSpecies)
plotsPerSpecies<-setNames(plotsPerSpecies, c("names", "numberOfPlots"))
row.names(plotsPerSpecies)<- c(1: length(uniqueSpecies))
end<- Sys.time()
round(end-begin)

parallel::stopCluster(cl = my.cluster)
#write_csv(plotsPerSpecies, "plotsPerSpeciesInEurope.csv")
```


## 7.2 Downsample
Determine which plant species have more than 10 plots with cover > 50% and cover < 1% for analysis:
```{r, message=F}
# Load data previously made with the number of plots per species across the dataset

# plotsPerSpecies <- read_csv("plotsPerSpeciesInEurope.csv")

parallel::detectCores()
n.cores <- parallel::detectCores() - 2
my.cluster <- parallel::makeCluster(
  n.cores, 
  type = "PSOCK"
)
print(my.cluster)
doParallel::registerDoParallel(cl = my.cluster)
foreach::getDoParRegistered()
foreach::getDoParWorkers()

# Get the names of the species which have at least 20 plots (since we want 10 smaller and 10 bigger)
candidatesForCoverClassAnalysis <- plotsPerSpecies$names[plotsPerSpecies$numberOfPlots >= 20]

# create empty vector
taxaForCoverClassAnalysis <- c()
# run for all candidates
begin<- Sys.time()
taxaForCoverAnalysis<- foreach(i= 1: length(candidatesForCoverClassAnalysis), .combine='rbind', .packages=c("dplyr","mgcv")) %dopar%  {
  # if the sum of all species with a cover of 50% for a species and less than 1% each are more than 10 
  # && makes sure to only look at the second if it is already T
  taxon<- candidatesForCoverClassAnalysis[i]
  if(sum(eva$species == taxon & eva$`Cover %` >= 50) > 10 && sum(eva$species == taxon & eva$`Cover %` < 1) > 10) {
    # write the species name to the list
    taxaForCoverClassAnalysis[i] <- c(taxon)
  }
}
end<- Sys.time()
round(end-begin)

parallel::stopCluster(cl = my.cluster)
##write_csv(data.frame(taxa = taxaForCoverClassAnalysis), "taxaForCoverClassAnalysis.csv")
```

## 7.3 New method
```{r}
plotsPerSpecies <- read_csv("speciesDominance_new_categorization_10.csv", show_col_types = FALSE)

taxa_new<- plotsPerSpecies[plotsPerSpecies$numberOfPlots >=50,]

#write_csv(data.frame(taxa = taxa_new), "taxa_new.csv")
```



# 8 LATER
```{r}
test<- read.csv("fullPlotData.csv")

hist(test$DistSeverity)
hist(sqrt(sqrt(test$DistFrequency)))
hist((test$Soil.Disturbance.sqrt))

sum(taxonNameCorrections$statusEurope=="native")
sum(taxonNameCorrections$statusEurope=="neo")
sum(taxonNameCorrections$statusEurope=="arch")
unique(taxonNameCorrections$species[taxonNameCorrections$statusEurope=="arch"])
```




# 9 To Do
TODO: how to handle niche width and number of original EIVs in EIVE to improve the estimation of the EIVE value in EVA?
TODO: also calculate richness without neophytes?
