---
title: "Impact analysis per class"
author: "Willem Goossens"
date: "`r Sys.Date()`"
output: html_document
---

Based on the best model as determined in the baseModelExploration.qmd we assess the impact of individual neophytes in this script. We compute impact of all plants in EVA based on the response ratio between observed and expected species richness and divide this over multiple cover classes.

# 1 START
We first clean the environment.
```{r, echo=F, warning=F, message=FALSE}
rm(list=ls())
gc()
```

We load the required packages
```{r, echo=F, message=F, warning=F}
library(readr)
library(dplyr)
library(mgcv)
library(modEvA)
library(ggplot2)
library(tidyr)
library(foreach)
library(doParallel)
library(rstatix)
library(DescTools)
library(asbio)
library(lme4)
library(glmmTMB)
```

## 1.1 Eva + header
We load the eva data with the species per plot
```{r}
eva <- read_csv("fullPlotEva_ESy.csv",show_col_types = FALSE)
```


Load filtered Data containing the richness and indicator values for each plot. In case we want to save computing time: down sample it:
```{r}
fullPlotData <- read_csv("fullPlotData_ESy.csv",show_col_types = FALSE)

fast <- T
if(fast) {
  fullPlotData <- fullPlotData[runif(length(fullPlotData$PlotObservationID)) > 0.90,]
  eva <- eva[eva$PlotObservationID %in% fullPlotData$PlotObservationID,]
}

#eva<- read.csv("downsampledEva.csv", header=T)
#colnames(eva)[8]<- "Cover %"
#fullPlotData<- read.csv("downsampledPlotData.csv")
```


## 1.2 Neophyte
Load the neophyte definitions:
```{r, message=F}
# Data on which species are neophytes
native_intra_analysis=F
if(native_intra_analysis){
  species_country_status<- read_csv("country_species_ESy.csv", show_col_types = FALSE)
} else{
  species_country_status<- read_csv("country_species_ESy.csv", show_col_types = FALSE)
  species_country_status$Neophyte[species_country_status$Neophyte=="native_intra"] <- "native"
# or if we want to do it with intra seperately
}

# Assign these names to the eva list
extra_EU <- unique(species_country_status$species[species_country_status$Neophyte=="extra"])
intra_EU <- unique(species_country_status$species[species_country_status$Neophyte=="intra"])
native_intra <- unique(species_country_status$species[species_country_status$Neophyte=="native_intra"])

```


Assign classification to species
```{r}
# Only observation ID and Region
fullPlot2<- fullPlotData[,c("PlotObservationID","Region")]
# Right join to keep only species present in fullplot (otherwise a lot of NAs)
eva<- right_join(eva, fullPlot2, by = c("PlotObservationID"="PlotObservationID"))
# Join eva and classification
eva_country_neophyte<- left_join(eva, species_country_status[, -c(2:4,6:8)], by= c("Region"= "Region", "name"= "name"))
# Look at how much from every type are present
table(eva_country_neophyte$Neophyte)
eva <- eva_country_neophyte
```



# 2 ANALYSIS
The idea is to compute the gam for every plot, which gives us the expected number of species based on the EIVE and DIV (and other indicators). We then compare this fitted (expected) values with the observed (real) species richness through the natural logarithm of the response ratio, which is defined as observed/ expected (commonly used in for example review papers on alien species).

Since Christians code is rather long, I try to simplify it by cutting it into more chunks.

## 2.1 Prepare
First, we make a list of the number of plots per species in our smaller dataset (if we do the analysis for all plots we can just make the file created earlier).
```{r, message=F}

if(fast) {
  reducedEva <- eva_country_neophyte |> select(PlotObservationID, Region,name, Neophyte,Layer,`Cover %`)

  reducedEva <- reducedEva |> group_by(PlotObservationID, Region,name, Neophyte, Layer) |> summarise(cover= sum(`Cover %`))
  
  reducedEva <- reducedEva|> group_by(PlotObservationID, Region, name, Neophyte) |> 
    summarise(cover = (1-prod((1-ifelse(cover/100>1, 1, cover/100 ))))*100)
  
  uniqueSpecies <- unique(reducedEva[, c(3,4)])
  
  # Empty dataset

  # Prepare parallel
  parallel::detectCores()
  n.cores <- parallel::detectCores() - 2
  my.cluster <- parallel::makeCluster(
    n.cores, 
    type = "PSOCK"
  )
  print(my.cluster)
  doParallel::registerDoParallel(cl = my.cluster)
  foreach::getDoParRegistered()
  foreach::getDoParWorkers()
  
  
  plotsPerSpecies <- data.frame(names = character(), numberOfPlots = integer(), Neophyte= character())
  # Count in how many plots a native species occurs
  begin<- Sys.time()
plotsPerSpecies<-foreach(i= 1:nrow(uniqueSpecies), .combine='rbind', .packages=c("dplyr","mgcv")) %dopar% {
    tmp <- reducedEva$PlotObservationID[reducedEva$name == uniqueSpecies$name[i]& 
                                          reducedEva$Neophyte == uniqueSpecies$Neophyte[i]]
    names=uniqueSpecies$name[i]
    numberOfPlots= length(unique(tmp))
    plotsPerSpecies[i,]<- c(names, numberOfPlots,Neophyte=uniqueSpecies$Neophyte[i] )
}

  plotsPerSpecies<- as.data.frame(plotsPerSpecies)
  plotsPerSpecies<-setNames(plotsPerSpecies, c("names", "numberOfPlots","Neophyte"))
  plotsPerSpecies$numberOfPlots <- as.numeric(plotsPerSpecies$numberOfPlots)
  row.names(plotsPerSpecies)<- c(1: nrow(uniqueSpecies))
  
  end<- Sys.time()
  round(end-begin)
  
  parallel::stopCluster(cl = my.cluster)
  #write.csv(plotsPerSpecies,"plotsPerSpeciesInEurope_native_intra.csv", row.names = F )
} else {
  if(!native_intra_analysis){
  plotsPerSpecies <- read_csv("speciesDominance.csv", show_col_types = FALSE)
  plotsPerSpecies <- plotsPerSpecies[,c(1,5:6)]
  colnames(plotsPerSpecies) <- c("names","numberOfPlots","neophyte")
  } else {
  plotsPerSpecies <- read_csv("speciesDominance_native_intra.csv", show_col_types = FALSE)
  plotsPerSpecies <- plotsPerSpecies[,c(1,5:6)]
  colnames(plotsPerSpecies) <- c("names","numberOfPlots","neophyte")
  }
}
```


Get the names of the species that are present in more than the required minimum number of plots
```{r, message=F}
minimumNumberOfPlots<- 30
taxaForCoverClassAnalysis <- plotsPerSpecies[plotsPerSpecies$numberOfPlots >= minimumNumberOfPlots,]

fullPlotData <- fullPlotData %>% 
    select(PlotObservationID, ENS0, Area, 
           EIVEresM, EIVEresN, EIVEresR, EIVEresL, EIVEresT, 
           DistSeverity.sqrt, Soil.Disturbance.sqrt, 
           Grazing.Pressure.sqrt, Mowing.Frequency.sqrt, 
           Latitude, Longitude, Dataset, chelsaP, hfp, elev)


total_cover <- reducedEva |> group_by(PlotObservationID) |> summarise(cover= sum(cover))
fullPlotData <- left_join(fullPlotData, total_cover[, c(1,2)])
colnames(fullPlotData)[19] <- "total"


alien_cover <- reducedEva |> group_by(PlotObservationID, Neophyte) |> summarise(cover= sum(cover), n= n())



fullPlotData <- left_join(fullPlotData, alien_cover[alien_cover$Neophyte=="extra", c(1,3)])
colnames(fullPlotData)[20] <- "extra"
fullPlotData$extra <- fullPlotData$extra / fullPlotData$total
fullPlotData <- left_join(fullPlotData, alien_cover[alien_cover$Neophyte=="intra", c(1,3)])
colnames(fullPlotData)[21] <- "intra"
fullPlotData$intra <- fullPlotData$intra / fullPlotData$total
fullPlotData <- left_join(fullPlotData, alien_cover[alien_cover$Neophyte=="native", c(1,3)])
colnames(fullPlotData)[22] <- "native"
fullPlotData$native <- fullPlotData$native / fullPlotData$total

fullPlotData <- left_join(fullPlotData, alien_cover[alien_cover$Neophyte=="extra", c(1,4)])
colnames(fullPlotData)[23] <- "extra_n"
fullPlotData$extra_n <- fullPlotData$extra_n / fullPlotData$ENS0
fullPlotData <- left_join(fullPlotData, alien_cover[alien_cover$Neophyte=="intra", c(1,4)])
colnames(fullPlotData)[24] <- "intra_n"
fullPlotData$intra_n <- fullPlotData$intra_n / fullPlotData$ENS0
fullPlotData <- left_join(fullPlotData, alien_cover[alien_cover$Neophyte=="native", c(1,4)])
colnames(fullPlotData)[25] <- "native_n"
fullPlotData$native_n <- fullPlotData$native_n / fullPlotData$ENS0
```



## 2.2 Base model
We compute our base model with the best solution (see [rmarkdown link](6_Base_Model.Rmd)), which includes smoothers for all EIVE without weighting, smoothers for the DIV, a smoother for log(area), a smoother for spatial autocorrelation and the dataset as a random effect. We use a quasipoisson distribution with a log link function. 

Note that this base model can be adjusted in future works based on what we decide (eg human footprint map values).
```{r}
# Make Dataset a factor
fullPlotData$Dataset <- as.factor(fullPlotData$Dataset)

scaled <- fullPlotData
scaled[, c(3:12, 16:25)] <- scale(scaled[, c(3:12, 16:25)], center=F, scale=T)

# GLMM
model<- glmer(ENS0 ~ log(Area) + EIVEresM+ EIVEresN+ EIVEresR+ EIVEresL+ EIVEresT+ 
                DistSeverity.sqrt+ Soil.Disturbance.sqrt+ Grazing.Pressure.sqrt+ Mowing.Frequency.sqrt+
                chelsaP+ hfp+ elev+ extra_n + intra_n+ native_n+  (1| Dataset), data= fullPlotData, family=Gamma(link = log))

model<- glmmTMB(ENS0 ~ log(Area) + EIVEresM + I(EIVEresM^2) +  EIVEresN + I(EIVEresN^2) + 
                    EIVEresR + I(EIVEresR^2) + EIVEresL + I(EIVEresL^2) + EIVEresT + I(EIVEresT^2) +
                    DistSeverity.sqrt + I(DistSeverity.sqrt^2) +Soil.Disturbance.sqrt + I(Soil.Disturbance.sqrt^2) +
                    Grazing.Pressure.sqrt + I(Grazing.Pressure.sqrt^2)+Mowing.Frequency.sqrt + I(Mowing.Frequency.sqrt^2)+
                    chelsaP+ I(chelsaP^2)+hfp+ I(hfp^2)+elev+ I(elev^2)+ Longitude*Latitude+ (1| Dataset), 
                    data= fullPlotData, family= poisson)

model<- glmmTMB(ENS0 ~ log(Area) + EIVEresM^2 +  EIVEresN^2 +EIVEresR^2 +EIVEresL^2 + EIVEresT^2 +
                    DistSeverity.sqrt^2 +Soil.Disturbance.sqrt^2 +Grazing.Pressure.sqrt^2 +Mowing.Frequency.sqrt^2+
                    chelsaP^2+ hfp^2+ elev^2+ Longitude*Latitude+ (1| Dataset), 
                    data= fullPlotData, family= poisson)

model<- glmmTMB(ENS0 ~ log(Area) + EIVEresM+ I(EIVEresM^2) + (1| Dataset), 
                    data= fullPlotData, family= poisson)

model<- glmmTMB(ENS0 ~ log(Area) + EIVEresM+EIVEresN+ extra + intra+ native+ (1| Dataset), 
                    data= fullPlotData, family= poisson)

summary(model)


model<-  ENS0 ~ 
              s(log(Area),bs='tp') + 
              s(EIVEresM, bs = 'tp') +
              s(EIVEresN, bs = 'tp') +
              s(EIVEresR, bs = 'tp') +
              s(EIVEresL, bs = 'tp') +
              s(EIVEresT, bs = 'tp') +
              s(DistSeverity.sqrt, bs = 'tp') +
              s(Soil.Disturbance.sqrt, bs = 'tp')+
              s(Grazing.Pressure.sqrt, bs = 'tp')+
              s(Mowing.Frequency.sqrt, bs = 'tp') +
              s(chelsaP, bs='tp')+
              s(hfp, bs='tp')+
              s(elev, bs='tp')+
              s(Latitude, Longitude, bs = 'tp') +
              s(Dataset, bs = 're')+
              s(extra, bs="tp")+
              s(intra, bs="tp")
              s(native, bs='tp')

baseModel <- bam(model,family = poisson, data = fullPlotData,  
                 method = 'fREML',  discrete=TRUE, nthreads=4)

summary(baseModel)
library(sjPlot)

plot_model(baseModel, type="pred", terms = c("EIVEresM [all]"))
plot_model(baseModel, type="pred", terms = c("EIVEresN [all]"))
plot_model(baseModel, type="pred", terms = c("EIVEresL [all]"))
plot_model(baseModel, type="pred", terms = c("EIVEresR [all]"))
plot_model(baseModel, type="pred", terms = c("EIVEresT [all]"))
plot_model(baseModel, type="pred", terms = c("DistSeverity.sqrt [all]"))
plot_model(baseModel, type="pred", terms = c("Soil.Disturbance.sqrt [all]"))
plot_model(baseModel, type="pred", terms = c("Grazing.Pressure.sqrt [all]"))
plot_model(baseModel, type="pred", terms = c("Mowing.Frequency.sqrt [all]"))
plot_model(baseModel, type="pred", terms = c("chelsaP [all]"))
plot_model(baseModel, type="pred", terms = c("elev [all]"))
plot_model(baseModel, type="pred", terms = c("hfp [all]"))
plot_model(baseModel, type="pred", terms = c("extra [all]"))
plot_model(baseModel, type="pred", terms = c("intra [all]"))
plot_model(baseModel, type="pred", terms = c("native [all]"))




mean(fitted(baseModel)[fullPlotData$EIVEresM==mean(fullPlotData$EIVEresM)])
mean(fitted(baseModel)[fullPlotData$EIVEresM== max(fullPlotData$EIVEresM)])

mean(fitted(model)[fullPlotData$EIVEresN== mean(fullPlotData$EIVEresN)])
mean(fitted(model)[max(fullPlotData$EIVEresN)])

mean(fitted(model)[fullPlotData$EIVEresN== max(fullPlotData$EIVEresN)])


```


