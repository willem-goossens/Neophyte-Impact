---
title: "Impact analysis per class"
author: "Willem Goossens"
date: "`r Sys.Date()`"
output: html_document
---

Based on the best model as determined in the baseModelExploration.qmd we assess the impact of individual neophytes in this script. We compute impact of all plants in EVA based on the response ratio between observed and expected species richness and divide this over multiple cover classes.

# 1 START
We first clean the environment.
```{r, echo=F, warning=F, message=FALSE}
rm(list=ls())
gc()
```

We load the required packages
```{r, echo=F, message=F, warning=F}
library(tidyverse)
library(mgcv)
library(doParallel)
library(DHARMa)
library(mgcViz)
library(ggeffects)
library(sp)
library(terra)
library(sf)
library(visreg)
library(ggpubr)
```


For complete data, load "I:/imporance.RData"


## 1.1 Eva + header
We load the eva data with the species per plot
```{r}
eva <- read_csv("../EVA data/fullPlotEva_new.csv",show_col_types = FALSE)
```


Load filtered Data containing the richness and indicator values for each plot. In case we want to save computing time: down sample it:
```{r}
fullPlotData <- read_csv("../EVA data/fullPlotData_new.csv",show_col_types = FALSE)
fullPlotData$Date <- as.Date(fullPlotData$Date, format = c("%Y-%m-%d"))
fullPlotData <- fullPlotData[fullPlotData$Date > "1980-01-01",]

fast <- T
if(fast) {
  fullPlotData <- fullPlotData[runif(length(fullPlotData$PlotObservationID)) > 0.99,]
  eva <- eva[eva$PlotObservationID %in% fullPlotData$PlotObservationID,]
}
```


## 1.2 Neophyte
Load the neophyte definitions:
```{r, message=F}
# Data on which species are neophytes
native_intra_analysis=F
if(native_intra_analysis){
  species_country_status<- read_csv("../EVA data/country_species_new.csv", show_col_types = FALSE)
} else{
  species_country_status<- read_csv("../EVA data/country_species_new.csv", show_col_types = FALSE)
  species_country_status$Neophyte[species_country_status$Neophyte=="native_intra"] <- "native"
# or if we want to do it with intra seperately
}

# Assign these names to the eva list
extra_EU <- unique(species_country_status$species[species_country_status$Neophyte=="extra"])
intra_EU <- unique(species_country_status$species[species_country_status$Neophyte=="intra"])
native_intra <- unique(species_country_status$species[species_country_status$Neophyte=="native_intra"])
```


Assign classification to species
```{r}
# Only observation ID and Region
fullPlot2<- fullPlotData[,c("PlotObservationID","Region")]
# Right join to keep only species present in fullplot (otherwise a lot of NAs)
eva<- right_join(eva, fullPlot2, by = c("PlotObservationID"="PlotObservationID"))
# Join eva and classification
eva_country_neophyte<- left_join(eva, species_country_status[, -c(2:4,6:8)], by= c("Region"= "Region", "name"= "name"))
# Look at how much from every type are present
table(eva_country_neophyte$Neophyte)
eva <- eva_country_neophyte

# there are still na's present --> due to being named 'plant'
nas<- eva_country_neophyte[is.na(eva_country_neophyte$Neophyte),]
eva_country_neophyte <- (eva_country_neophyte[!eva_country_neophyte$name=="Plant",])
eva <- eva[!eva$name=="Plant",]
```



# 2 ANALYSIS
The idea is to compute the gam for every plot, which gives us the expected number of species based on the EIVE and DIV (and other indicators). We then compare this fitted (expected) values with the observed (real) species richness through the natural logarithm of the response ratio, which is defined as observed/ expected (commonly used in for example review papers on alien species).

Since Christians code is rather long, I try to simplify it by cutting it into more chunks.

## 2.1 Prepare
First, we make a list of the number of plots per species in our smaller dataset (if we do the analysis for all plots we can just make the file created earlier).
```{r, message=F}
colnames(eva_country_neophyte)[9] <- "Cover %"
# create smaller dataset
reducedEva <- eva_country_neophyte |> dplyr::select(PlotObservationID, Region,name,
                                             Neophyte,Layer,`Cover %`)

# sum cover species per plot
reducedEva <- reducedEva |> group_by(PlotObservationID, Region,name, Neophyte, Layer) |>
  summarise(cover= sum(`Cover %`))

# Fisher methode  
reducedEva <- reducedEva|> group_by(PlotObservationID, Region, name, Neophyte) |>
  summarise(cover = (1-prod((1-ifelse(cover/100>1, 1, cover/100 ))))*100)

# create vector unique species 
uniqueSpecies <- unique(reducedEva[, c(3,4)])

if(fast) {
  # Prepare parallel
  parallel::detectCores()
  n.cores <- parallel::detectCores() - 2
  my.cluster <- parallel::makeCluster(
    n.cores, 
    type = "PSOCK"
  )
  print(my.cluster)
  doParallel::registerDoParallel(cl = my.cluster)
  foreach::getDoParRegistered()
  foreach::getDoParWorkers()
  
  # empty dataset
  plotsPerSpecies <- data.frame(names = character(), numberOfPlots = integer(), 
                                Neophyte= character())
  # Count in how many plots a native species occurs
  begin<- Sys.time()
  plotsPerSpecies<-foreach(i= 1:nrow(uniqueSpecies), .combine='rbind',
                           .packages=c("dplyr","mgcv")) %dopar% {
      tmp <- reducedEva$PlotObservationID[reducedEva$name == uniqueSpecies$name[i]& 
                                            reducedEva$Neophyte == uniqueSpecies$Neophyte[i]]
      names=uniqueSpecies$name[i]
      numberOfPlots= length(unique(tmp))
      plotsPerSpecies[i,]<- c(names, numberOfPlots,Neophyte=uniqueSpecies$Neophyte[i] )
  }

  plotsPerSpecies<- as.data.frame(plotsPerSpecies)
  plotsPerSpecies<-setNames(plotsPerSpecies, c("names", "numberOfPlots","Neophyte"))
  plotsPerSpecies$numberOfPlots <- as.numeric(plotsPerSpecies$numberOfPlots)
  row.names(plotsPerSpecies)<- c(1: nrow(uniqueSpecies))
  
  end<- Sys.time()
  round(end-begin)
  
  parallel::stopCluster(cl = my.cluster)
} else {
  if(!native_intra_analysis){
  plotsPerSpecies <- read_csv("../Results/speciesDominance_1980.csv", show_col_types = FALSE)
  plotsPerSpecies <- plotsPerSpecies[,c(1,5:6)]
  } else {
  plotsPerSpecies <- read_csv("../Results/speciesDominance_1980_native_intra.csv", show_col_types = FALSE)
  plotsPerSpecies <- plotsPerSpecies[,c(1,5:6)]
  colnames(plotsPerSpecies) <- c("names","numberOfPlots","neophyte")
  }
}
```


Get the names of the species that are present in more than the required minimum number of plots
```{r, message=F}
# downsize number of species
minimumNumberOfPlots<- 30
taxaForCoverClassAnalysis <- plotsPerSpecies[plotsPerSpecies$numberOfPlots >=
                                               minimumNumberOfPlots,]

# downsize fullPlotData
fullPlotData <- fullPlotData %>% 
    dplyr::select(PlotObservationID, ENS0, Area, 
           EIVEresM, EIVEresN, EIVEresR, EIVEresL, EIVEresT, 
           DistSeverity.sqrt , Soil.Disturbance.sqrt , 
           Grazing.Pressure.sqrt , Mowing.Frequency.sqrt , 
           Latitude, Longitude, Dataset, chelsaP, hfp, elev)
```


Compute some metrics on alien and native species
```{r, message=F}
# compute total cover per size and add to the fullPlotData
total_cover <- reducedEva |> group_by(PlotObservationID) |> summarise(cover= sum(cover))
fullPlotData <- left_join(fullPlotData, total_cover[, c(1,2)])
colnames(fullPlotData)[19] <- "total"


# calculate the sum of cover per plot per class (alien or native) and number of species
alien_cover <- reducedEva |> group_by(PlotObservationID, Neophyte) |> 
  summarise(cover= sum(cover), n= n())

# add fullPlotData plot info and total cover
alien_cover <- left_join(alien_cover, fullPlotData[,c(1,2,19)])
# calculated weighted values
alien_cover <- alien_cover |> mutate(cover_rel= cover/total, n_rel=n/ENS0, 
                                     n_weighted= cover/total/n*ENS0,
                                     DI = (cover/total + n/ENS0)/2)

# make column per value
test <- alien_cover |> pivot_wider(names_from = c(Neophyte),
                                   values_from = c(cover, n, cover_rel, n_rel,n_weighted, DI))

# add to full plot data
fullPlotData <- left_join(fullPlotData, test)
```



## 2.2 Base model
Downsize dataset and make NAs zero
```{r}
rel_extra <- sum(!is.na(fullPlotData$cover_rel_extra))/ length(fullPlotData$PlotObservationID)
rel_intra <- sum(!is.na(fullPlotData$cover_rel_intra))/ length(fullPlotData$PlotObservationID) 

downsize =F
if(downsize){ 
  if(rel_intra< 0.10){
    needed_size <- (sum(!is.na(fullPlotData$cover_rel_intra))/0.10)-sum(!is.na(fullPlotData$cover_rel_intra))-
      sum(!is.na(fullPlotData$cover_rel_extra)& is.na(fullPlotData$cover_rel_intra))
    data_to_sample <- fullPlotData[is.na(fullPlotData$cover_rel_intra)& is.na(fullPlotData$cover_rel_extra),]
    sample <- sample(data_to_sample$PlotObservationID, needed_size, replace=F)
    update <- data_to_sample[data_to_sample$PlotObservationID %in% sample,]
    subset_data <- rbind(fullPlotData[!is.na(fullPlotData$cover_rel_intra),],update, 
                         fullPlotData[is.na(fullPlotData$cover_rel_intra)& !is.na(fullPlotData$cover_rel_extra),])
    size<- length(subset_data$PlotObservationID)
  }
  fullPlotData <- subset_data
}

# make all NAs zero
fullPlotData[is.na(fullPlotData)] <- 0

# Make Dataset a factor
fullPlotData$Dataset <- as.factor(fullPlotData$Dataset)
```


Scaling or not?
```{r}
# scale or not
scaled=F
if(scaled){
  
  # copy dataset for original values
  fullPlotData2 <-fullPlotData

  # scale data 
  fullPlotData[, c(4:12,13:14, 16:18, 20:22, 24:37)] <- 
    scale(fullPlotData[, c(4:12,13:14, 16:18,20:22, 24:37)], center=F, scale=T)
}
```




## 2.3 GAMM
Compare with the gamm model
```{r}
# this is the model 
# we take the log of the area already (cannot be in model)
fullPlotData$Area <- log(fullPlotData$Area)

# final model
model<-  n_native ~ 
              s(Area,bs='tp') + 
              s(EIVEresM, bs = 'tp') +
              s(EIVEresN, bs = 'tp') +
              s(EIVEresR, bs = 'tp') +
              s(EIVEresL, bs = 'tp') +
              s(EIVEresT, bs = 'tp') +
              s(DistSeverity.sqrt, bs = 'tp') +
              s(Soil.Disturbance.sqrt, bs = 'tp')+
              s(Grazing.Pressure.sqrt, bs = 'tp')+
              s(Mowing.Frequency.sqrt, bs = 'tp') +
              s(hfp, bs="tp")+
              s(chelsaP, bs="tp")+
              s(elev, bs='tp')+
              s(DI_intra, bs="tp", k=5) + s(DI_extra, bs="tp", k=5)+
              s(Latitude, Longitude, bs = 'tp')

# run gamm
mod <- bam(model, family = nb(), data = fullPlotData,  
                 method = 'fREML',  discrete=T, nthreads=4)

gam.check(mod)

sum <- summary(mod)
sum
```


```{r}
# create simulation data
simulationOutput <- simulateResiduals(fittedModel = mod, plot = F)
# look at simulation 
# QQ plot --> line normal (is it correct distribution and is there no overdispersion)
# residual plot --> if correct line at 0.5
plot(simulationOutput)

# test dispersion
testDispersion(simulationOutput)
plotResiduals(simulationOutput)
```


```{r}
source("../Extra data/GAM.HP/gam.hp.R")
source("../Extra data/GAM.HP/creatbin.R")
source("../Extra data/GAM.HP/genList.R")
source("../Extra data/GAM.HP/plot.gamhp.R")


z <- gam.hp(mod, type="dev")
z
plot(z)
```


I made the graph here...
```{r}
var = c("EIVEresT","EIVEresN","EIVEresM","EIVEresR","EIVEresL","DistSeverity.sqrt",
        "Soil.Disturbance.sqrt","Grazing.Pressure.sqrt","Mowing.Frequency.sqrt","hfp",
        "DI_intra","DI_extra")
i=c(1:12)
plotList <- lapply(
  i ,
  FUN= function(i){
    j <- var[i]
    plot_pred <- ggeffects::predict_response(mod, j)
    plot_end <- ggplot(plot_pred, aes(x=x, y= predicted))+
                      geom_line()+
                      geom_ribbon(aes(ymin= conf.low, ymax=conf.high), alpha=0.2)+
                      xlab(j) #+
                      #geom_point(data= fullPlotData, 
                                 #aes(x= as.vector(fullPlotData[, colnames(fullPlotData)==j]), y= n_native))
    assign(paste("plot_", i,sep=""), plot_end)
    plot_end
    }
)

plot <- ggpubr::ggarrange(plotlist= plotList, ncol=3, nrow=4, labels= letters[1:12])
plot
```


## 2.4 GAMM EXTRA
Compare with the gamm model
```{r}
# this is the model 
# we take the log of the area already (cannot be in model)

model2<-  n_extra ~ 
              s(Area,bs='tp') + 
              s(EIVEresM, bs = 'tp') +
              s(EIVEresN, bs = 'tp') +
              s(EIVEresR, bs = 'tp') +
              s(EIVEresL, bs = 'tp') +
              s(EIVEresT, bs = 'tp') +
              s(DistSeverity.sqrt, bs = 'tp') +
              s(Soil.Disturbance.sqrt, bs = 'tp')+
              s(Grazing.Pressure.sqrt, bs = 'tp')+
              s(Mowing.Frequency.sqrt, bs = 'tp') +
              s(hfp, bs="tp")+
              s(chelsaP, bs="tp")+
              s(elev, bs='tp')

# run gamm
mod2 <- bam(model2, family= nb(), data = fullPlotData,  method = 'fREML',  discrete=T, nthreads=4)

sum2 <- summary(mod2)
sum2
```


```{r}
# create simulation data
simulationOutput <- simulateResiduals(fittedModel = mod2, plot = F)
# look at simulation 
# QQ plot --> line normal (is it correct distribution and is there no overdispersion)
# residual plot --> if correct line at 0.5
plot(simulationOutput)

# test dispersion
testDispersion(simulationOutput)
plotResiduals(simulationOutput)
```





```{r}
z_extra <- gam.hp(mod2, type="dev")
z_extra

change <- data.frame(old= test,
                     new = c("Area","EIVE M","EIVE N","EIVE R","EIVE L","EIVE T","DIV severity",
                             "DIV soil","DIV grazing","DIV mowing","HFP","MAP","Elevation"))
rownames(z_extra$hierarchical.partitioning) <- change$new
z_extra$variables <- change$new
plot(z_extra)


```
```{r}
# get values
plot_data = data.frame(variable = rownames(z_extra[[2]]),
                       value = as.numeric(z_extra[[2]][, "I.perc(%)"]))

# change names
plot_data$variable <-  c("Area", "EIVE M", "EIVE N", "EIVE R","EIVE L", "EIVE T", "DIV severity","DIV soil",
                         "DIV grazing","DIV mowing","HFP","MAP","Elevation")

# classify in types
plot_data$type <- c(1,2,2,2,2,2,3,3,3,3,3,2,2)
plot_data$type <- as.factor(plot_data$type)
colnames(plot_data)[3] <- c("type")
plot_data <- plot_data %>% mutate(type = factor(type, 
                          levels = c("1", "2","3","5","4"),
                          labels = c("Plot", 
                                     "Environment", 
                                     "Disturbance",
                                     "Extra-European alien",
                                     "Intra-European alien"
                                     )))

# Define soft pastel colours for each type
pastel_colours <- c( "Plot" = "#999999",  "Environment" = "violetred2","Disturbance" = "lightblue", "Extra-European alien" = "deepskyblue2",  
                     "Intra-European alien" = "steelblue"   )

# plot data
plot <- ggplot(plot_data, aes(x= reorder(variable, -value), y= value, fill=type))+
  geom_bar(stat = "identity")+
  scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
  scale_fill_manual(values= pastel_colours, name= "Variable type")+
  NULL+
  theme_bw()+
  xlab("Variable type")+
  ylab("Explained variance (%)")+
  theme(legend.position = "bottom",
          legend.box = "vertical")
plot
```

```{r}
var = c("EIVEresT","EIVEresN","EIVEresM","EIVEresR","EIVEresL","DistSeverity.sqrt",
        "Soil.Disturbance.sqrt","Grazing.Pressure.sqrt","Mowing.Frequency.sqrt","hfp")
i=c(1:10)
plotList <- lapply(
  i ,
  FUN= function(i){
    j <- var[i]
    plot_pred <- ggeffects::predict_response(mod2, j)
    plot_end <- ggplot(plot_pred, aes(x=x, y= predicted))+
                      geom_line()+
                      geom_ribbon(aes(ymin= conf.low, ymax=conf.high), alpha=0.2)+
                      xlab(j)
                      #geom_point(data= fullPlotData, 
                                 #aes(x= as.vector(fullPlotData[, colnames(fullPlotData)==j]), y= n_native))
    assign(paste("plot_", i,sep=""), plot_end)
    plot_end
    }
)

plot <- ggpubr::ggarrange(plotlist= plotList, ncol=3, nrow=4, labels= letters[1:12])
plot
```


## 2.5 GAMM INTRA
```{r}
# this is the model 
# we take the log of the area already (cannot be in model)

model3<-  n_intra ~ 
              s(Area,bs='tp') + 
              s(EIVEresM, bs = 'tp') +
              s(EIVEresN, bs = 'tp') +
              s(EIVEresR, bs = 'tp') +
              s(EIVEresL, bs = 'tp') +
              s(EIVEresT, bs = 'tp') +
              s(DistSeverity.sqrt, bs = 'tp') +
              s(Soil.Disturbance.sqrt, bs = 'tp')+
              s(Grazing.Pressure.sqrt, bs = 'tp')+
              s(Mowing.Frequency.sqrt, bs = 'tp') +
              s(hfp, bs="tp")+
              s(chelsaP, bs="tp")+
              s(elev, bs='tp')

# run gamm
mod3 <- bam(model3, family= nb(), data = fullPlotData,  method = 'fREML',  discrete=T, nthreads=4)

sum3 <- summary(mod3)
sum3
```


```{r}
# create simulation data
simulationOutput <- simulateResiduals(fittedModel = mod3, plot = F)
# look at simulation 
# QQ plot --> line normal (is it correct distribution and is there no overdispersion)
# residual plot --> if correct line at 0.5
plot(simulationOutput)

# test dispersion
testDispersion(simulationOutput)
plotResiduals(simulationOutput)
```




```{r}
visreg(mod3, xvar = "EIVEresN", ylab = "Richness" ,gg = TRUE, partial=FALSE, rug = FALSE,  scale="response") 
visreg(mod3, xvar = "DistSeverity.sqrt", ylab = "Richness" ,gg = TRUE, partial=FALSE, rug = FALSE,  scale="response")
visreg(mod3, xvar = "Soil.Disturbance.sqrt", ylab = "Richness" ,gg = TRUE, partial=FALSE, rug = FALSE,  scale="response")
visreg(mod3, xvar = "Mowing.Frequency.sqrt", ylab = "Richness" ,gg = TRUE, partial=FALSE, rug = FALSE,  scale="response")
visreg(mod3, xvar = "Grazing.Pressure.sqrt", ylab = "Richness" ,gg = TRUE, partial=FALSE, rug = FALSE,  scale="response")
visreg(mod3, xvar = "hfp", ylab = "Richness" ,gg = TRUE, partial=FALSE, rug = FALSE,  scale="response")
```



```{r}
z_intra <- gam.hp(mod3, type="dev")
z_intra
change <- data.frame(old= test,
                     new = c("Area","EIVE M","EIVE N","EIVE R","EIVE L","EIVE T","DIV severity",
                             "DIV soil","DIV grazing","DIV mowing","HFP","MAP","Elevation"))
rownames(z_intra$hierarchical.partitioning) <- change$new
z_intra$variables <- change$new

plot(z_intra)
```



# 3 PLOT
## 3.1 Variance
```{r}
library(rlist)
library(ggsci)

# load data
load(file = "I:/importance.Rdata") 
# plot data
plot(z)

# get values
plot_data = data.frame(variable = rownames(z[[2]]),
                       value = as.numeric(z[[2]][, "I.perc(%)"]))

plot_data_intra = data.frame(variable = rownames(z_intra[[2]]),
                       value = as.numeric(z_intra[[2]][, "I.perc(%)"]))

plot_data_extra = data.frame(variable = rownames(z_extra[[2]]),
                       value = as.numeric(z_extra[[2]][, "I.perc(%)"]))

# change names
plot_data$variable <-  c("Area", "EIVE M", "EIVE N", "EIVE R","EIVE L", "EIVE T", "DIV severity","DIV soil",
                         "DIV grazing","DIV mowing","HFP","MAP","Elevation","Intra","Extra")

plot_data_intra$variable <-  c("Area", "EIVE M", "EIVE N", "EIVE R","EIVE L", "EIVE T", "DIV severity","DIV soil",
                         "DIV grazing","DIV mowing","HFP","MAP","Elevation")

plot_data_extra$variable <-  c("Area", "EIVE M", "EIVE N", "EIVE R","EIVE L", "EIVE T", "DIV severity","DIV soil",
                         "DIV grazing","DIV mowing","HFP","MAP","Elevation")


# classify in types
plot_data$type <- c(1,2,3,3,2,2,4,4,4,4,4,2,2, 5,6)
plot_data$type <- as.factor(plot_data$type)
colnames(plot_data)[3] <- c("type")
plot_data <- plot_data %>% mutate(type = factor(type, 
                          levels = c("1", "2","3","4","6","5"),
                          labels = c("Plot", 
                                     "Environment",
                                     "Soil nitrogen and reaction",
                                     "Disturbance",
                                     "Extra-European alien",
                                     "Intra-European alien"
                                     )))
plot_data$Neophyte <- "native"

# classify in types
plot_data_intra$type <- c(1,2,3,3,2,2,4,4,4,4,4,2,2)
plot_data_intra$type <- as.factor(plot_data_intra$type)
colnames(plot_data_intra)[3] <- c("type")
plot_data_intra <- plot_data_intra %>% mutate(type = factor(type, 
                          levels = c("1", "2","3","4","6","5"),
                          labels = c("Plot", 
                                     "Environment",
                                     "Soil nitrogen and reaction",
                                     "Disturbance",
                                     "Extra-European alien",
                                     "Intra-European alien"
                                     )))
plot_data_intra$Neophyte <- "intra"


# classify in types
plot_data_extra$type <- c(1,2,3,3,2,2,4,4,4,4,4,2,2)
plot_data_extra$type <- as.factor(plot_data_extra$type)
colnames(plot_data_extra)[3] <- c("type")
plot_data_extra <- plot_data_extra %>% mutate(type = factor(type, 
                          levels = c("1", "2","3","4","6","5"),
                          labels = c("Plot", 
                                     "Environment",
                                     "Soil nitrogen and reaction",
                                     "Disturbance",
                                     "Extra-European alien",
                                     "Intra-European alien"
                                     )))
plot_data_extra$Neophyte <- "extra"

my_palette <- c(
  "#1b9e77",  # Blue-Green
  "#d95f02",  # Golden Yellow
  "#7570b3",  # Soft Purple
  "#66c2a5",  # Sky Blue
  "#004D40",  # Warm Pink
   "#FFC107"   # Pale Yellow-Green
)


# combine
plotting <- rbind(plot_data, plot_data_intra, plot_data_extra)

# plot data
plot <- ggplot(plot_data, aes(x= reorder(variable, -value), y= value, fill=type))+
  geom_bar(position= "stack",stat = "identity")+
  scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
  NULL+
  theme_bw()+
  xlab("Variable type")+
  ylab("Explained variance (%)")+
  scale_fill_manual(values= my_palette, name= "Variable type")+
  theme(legend.position = "bottom",
          legend.box = "vertical")
plot

plot_sum <- plotting |> group_by(Neophyte, type) |> summarise(value= sum(value))
plot_sum$name <- "native"


# plot data
plot_variance <- ggplot(plot_sum, aes(x=Neophyte, y= value, fill=type))+
              geom_bar(position= "stack",stat = "identity")+
              ggpubr::theme_pubr()+
              theme(legend.position = "right")+
              scale_fill_manual(values= my_palette, name= "Variable type") +
              scale_x_discrete(labels=c("Extra-\nEuropean", "Intra-\nEuropean", "Native", "Native\nalien elsewhere"))+
              xlab(NULL)+
              ylab("Variance\nexplained [%]")+
              theme(axis.text.x=element_text(size=12), axis.title.y=element_text(size=12), axis.title.x=element_blank(), 
                    axis.text.y=element_text(size=10))
              
plot_variance

#ggsave("../Images/variance.png", width=7.5, height=5)
```



## 3.2 Plots
```{r}
# choose model for which you want to plot
analysis <- "Native SR"
if(analysis == "Native SR"){
  MDL <- mod
} else if(analysis == "Extra-\nEuropean SR"){
  MDL <- mod2
} else {
  MDL <- mod3
}

# create vector for variables
variables = data.frame(var = c("EIVEresT","EIVEresN","EIVEresM","EIVEresR","EIVEresL","DistSeverity.sqrt","Soil.Disturbance.sqrt",
                               "Grazing.Pressure.sqrt","Mowing.Frequency.sqrt", "hfp","DI_extra", "DI_intra"),
                 type= c(2,3,2,3,2,4,4,4,4,4,5,6), 
                 name = c("EIVE T", "EIVE N", "EIVE M","EIVE R", "EIVE L", "DIV severity", "DIV soil", "DIV grazing","DIV mowing",
                          "HFP","APP extra-European", "APP intra-European"))
variables$color <-my_palette[variables$type]


# function to create plot
create_plot= function(name){
    model_name <-  variables[variables$name == name,1]
    col<- variables[variables$name == name,4]
    
    plot_pred <- ggeffects::predict_response(MDL, model_name)
    mean(plot_pred$predicted)
    
    y_max <- max(plot_pred$predicted, na.rm = TRUE) * 1.25
    y_min <-  min(plot_pred$predicted, na.rm = TRUE) * 0.75
    
    plot_end <- ggplot(plot_pred, aes(x=x, y= predicted, color=col, fill= col))+
                      geom_line(linewidth=2)+
                      scale_colour_manual(values=col)+
                      scale_fill_manual(values = col)+
                      geom_ribbon(aes(ymin= conf.low, ymax=conf.high), alpha=0.2, linetype=0)+
                      xlab(name)+
                      ggpubr::theme_pubr()+
                      xlab(name)+
                      ylab(analysis)+
                      theme(legend.position = "none")
    
      if (analysis != "Native SR") {plot_end <- plot_end + coord_cartesian(ylim = c(y_min, y_max))} else {
        plot_end <- plot_end
      }
}

# get the relevant plots
plot_EIVE_N <- create_plot("EIVE N")
plot_EIVE_R <- create_plot("EIVE R")
if(analysis == "Native SR"){
  plot_intra <- create_plot("APP intra-European")
  plot_extra <- create_plot("APP extra-European")
}
plot_hfp <- create_plot("HFP")
plot_sev <- create_plot("DIV severity")

# combine

if(analysis == "Native SR"){
  plot <- ggpubr::ggarrange(plot_EIVE_N, plot_EIVE_R, plot_hfp, plot_sev, plot_extra, plot_intra,  ncol=2, nrow=3, labels= letters[1:6], 
                          common.legend = F)
} else {
  plot <- ggpubr::ggarrange(plot_EIVE_N, plot_EIVE_R, plot_hfp, plot_sev,  ncol=2, nrow=2, labels= letters[1:6], 
                          common.legend = F)
}
plot

```


## 3.3 Together plots
```{r}
# choose model for which you want to plot

# create vector for variables
variables = data.frame(var = c("EIVEresT","EIVEresN","EIVEresM","EIVEresR","EIVEresL","DistSeverity.sqrt","Soil.Disturbance.sqrt",
                               "Grazing.Pressure.sqrt","Mowing.Frequency.sqrt", "hfp","DI_extra", "DI_intra"),
                 type= c(2,3,2,3,2,4,4,4,4,4,5,6), 
                 name = c("EIVE T", "Soil nitrogen (EIVE)", "EIVE M","Soil reaction (EIVE)", "EIVE L", "Disturbance severity (DIV)", "DIV soil", 
                          "DIV grazing","DIV mowing","Human Footprint","APP extra-European", "APP intra-European"))
variables$color <-my_palette[variables$type]


# function to create plot
create_plot= function(name){
    model_name <-  variables[variables$name == name,1]
    col<- variables[variables$name == name,4]
    
    plot_pred_nat <- ggeffects::predict_response(mod, model_name)
    plot_pred_extra <- ggeffects::predict_response(mod2, model_name)
    plot_pred_intra <- ggeffects::predict_response(mod3, model_name)
    
    plot_pred_nat$Neophyte <- "Native"
    plot_pred_extra$Neophyte <- "Extra-European"
    plot_pred_intra$Neophyte <- "Intra-European"
    
    y_min <- min(c(plot_pred_extra$predicted, plot_pred_intra$predicted), na.rm = TRUE) *0.9
    y_max <-  max(c(plot_pred_extra$predicted, plot_pred_intra$predicted), na.rm = TRUE) *1.1
    scale_factor <- max(plot_pred_nat$predicted, na.rm = TRUE) / max(c(plot_pred_extra$predicted, plot_pred_intra$predicted), na.rm = TRUE)
    
    
    # Base plot with Native on primary y-axis
    plot_end <- ggplot() +
      # Native (left axis)
      geom_line(data = plot_pred_nat, aes(x = x, y = predicted, color = Neophyte), linewidth = 1.2) +
      geom_ribbon(data = plot_pred_nat, aes(x = x, ymin = conf.low, ymax = conf.high, fill = Neophyte), alpha = 0.2) +
      
      # Extra-European (right axis, scaled)
      geom_line(data = plot_pred_extra, aes(x = x, y = predicted * scale_factor, color = Neophyte), linewidth = 1.2) +
      geom_ribbon(data = plot_pred_extra, aes(x = x, ymin = conf.low* scale_factor, ymax = conf.high* scale_factor, fill = Neophyte), alpha = 0.2) +
      
      # Intra-European (right axis, scaled)
      geom_line(data = plot_pred_intra, aes(x = x, y = predicted* scale_factor, color = Neophyte), linewidth = 1.2) +
      geom_ribbon(data = plot_pred_intra, aes(x = x, ymin = conf.low* scale_factor, ymax = conf.high* scale_factor, fill =Neophyte), alpha = 0.2) +
      scale_colour_manual(values=c("Extra-European"= "#004D40","Intra-European" ="#FFC107","Native"="#1E88E5"))+
      scale_fill_manual(values=c("Extra-European"= "#004D40","Intra-European" ="#FFC107","Native"="#1E88E5"))+ 
      scale_y_continuous(
        name = "Native SR",
        sec.axis = sec_axis(~ . / scale_factor, name = "Alien SR")
      ) +
      coord_cartesian(ylim = c(y_min*scale_factor, y_max*scale_factor))+
      xlab(name) +
      ggpubr::theme_pubr() +
      ylab(analysis) +
      theme(legend.position = "bottom") +
      theme(axis.title.y.right = element_text(angle = 90))
}

# function to create plot
create_plot_alien= function(name){
    model_name <-  variables[variables$name == name,1]
    col<- variables[variables$name == name,4]
    
    plot_pred_nat <- ggeffects::predict_response(mod, model_name)
    
    plot_pred_nat$Neophyte <- ifelse(name=="APP intra-European", "Intra-European", "Extra-European")

    # Base plot with Native on primary y-axis
    plot_end <- ggplot() +
      # Native (left axis)
      geom_line(data = plot_pred_nat, aes(x = x, y = predicted, color = Neophyte), linewidth = 1.2) +
      geom_ribbon(data = plot_pred_nat, aes(x = x, ymin = conf.low, ymax = conf.high, fill = Neophyte), alpha = 0.2) +
      scale_colour_manual(values=c("Extra-European"= "#004D40","Intra-European" ="#FFC107","Native"="#1E88E5"))+
      scale_fill_manual(values=c("Extra-European"= "#004D40","Intra-European" ="#FFC107","Native"="#1E88E5"))+ 
      scale_y_continuous(
        name = "Native SR" ) +
      xlab(name) +
      ggpubr::theme_pubr() +
      ylab(analysis) +
      theme(legend.position = "bottom") 
}

# get the relevant plots
plot_EIVE_N <- create_plot("Soil nitrogen (EIVE)")
plot_EIVE_R <- create_plot("Soil reaction (EIVE)")
plot_hfp <- create_plot("Human Footprint")
plot_sev <- create_plot("Disturbance severity (DIV)")
plot_intra <- create_plot_alien("APP intra-European")
plot_extra <- create_plot_alien("APP extra-European")

# combine

plot_all <-  ggarrange(plot_variance, 
                       ggarrange(plot_EIVE_N, plot_EIVE_R, plot_hfp, plot_sev,  plot_intra, plot_extra, ncol=2, nrow=3, labels= letters[2:7], 
                                 common.legend = T,legend="bottom", align="hv"), nrow=2, labels= letters[1], heights= c(1,2))
plot_all

ggsave("../Images/Variance.png", width=8, height=8)
```


# 4 MAP
```{r}
# get regions back to FullPlotData
fullPlotData$Region <- fullPlot2$Region[match(fullPlotData$PlotObservationID, fullPlot2$PlotObservationID)]
colnames(fullPlotData)
map <- fullPlotData[, c(1,38,13,14, 2,20:22, 23, 24, 25)]
colnames(map)
#map[is.na(map)] <- 0

map$DI_alien <- ((map$cover_extra+map$cover_intra)/(map$cover_extra+map$cover_intra+ map$cover_native) +
                 (map$n_extra+map$n_intra)/(map$n_extra+map$n_intra+map$n_native))/2

map$alien <- map$n_intra+ map$n_extra

density <- map |> group_by(Region) |> summarise(rel_invaded = sum(!is.na(n_extra)|!is.na(n_intra))/length(PlotObservationID))
```


```{r}
# We load the Med regions and give correct CRS
medRegions <- read_sf("../Extra data/EURO+MED/Regions", "Emed_regions")
medRegions <- st_transform(medRegions, CRS("+proj=longlat +datum=WGS84"))
density <- left_join(medRegions, density, by= c("Region"="Region"))

rel_invaded<- ggplot()+
  geom_sf(data= density, aes(fill= rel_invaded))+
  scale_fill_viridis_c(option = "magma",begin = 0.1)+
  labs(title = "Relative number of invaded plots") +
  theme_bw()


#ggsave(rel_invaded, file="rel_invaded.png", bg="white")
```



```{r}
library(rnaturalearth)
library(rnaturalearthdata)
library(ggspatial)
library(marmap) 
library(ggnewscale)

# Step 0: Load world map and bathymetry data
world <- ne_countries(scale = "medium", returnclass = "sf")

# Define Europe bounding box
map_bbox <- c(-20, 65, 34, 72)  

# Download bathymetry data
bathy_data <- getNOAA.bathy(
  lon1 = map_bbox[1], lon2 = map_bbox[2],
  lat1 = map_bbox[3], lat2 = map_bbox[4],
  resolution = 5
)

# Convert bathymetry to raster
bathy_raster <- marmap::as.raster(bathy_data)
bathy_df <- as.data.frame(as(bathy_raster, "SpatialPixelsDataFrame"))
colnames(bathy_df) <- c("elevation", "x", "y")


# 1. Read and transform Europe shapefile
medRegions <- read_sf("../Extra data/EURO+MED/Regions", "Emed_regions")  %>%
  st_transform(4326)  # EPSG:3035 (Projected CRS for Europe)

# 2. Read and transform observation points
plotLocations <- st_as_sf(map, coords = c("Longitude", "Latitude"), remove = FALSE) %>%
  st_set_crs(4326) %>%
  st_transform(4326)

# 3. Create a grid over Europe
grid <- st_make_grid(medRegions, cellsize = 0.5, square = TRUE) %>% 
  st_sf() 


sf_use_s2(F)
grid <- grid |> st_as_sf() |> # cast to sf
  mutate(grid_id = row_number()) |> # create unique ID
  st_join(plotLocations) |> # join the species dataset
  group_by(grid_id)  |> # group by the grid id
  summarise(mean = mean(DI_alien, na.rm=T)) 
sf_use_s2(T)


sf_use_s2(F)
# 4. Count observations per grid cell
grid$invaded_cells <-  lengths(st_intersects(grid, plotLocations[plotLocations$alien >0,]))/ lengths(st_intersects(grid, plotLocations)) 
sf_use_s2(T)


# 5. Convert grid to a dataframe for plotting
grid_df <- as.data.frame(st_coordinates(st_centroid(grid))) %>%
  mutate(count = grid$invaded_cells, mean = grid$mean)

grid_df$count <- grid_df$count * 100
grid_df$mean <- grid_df$mean * 100

# hfp
hfp2009<- rast("../Extra data/DIV/HFP2009.tif")
mollweide_crs <- "+proj=moll +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs"
europe_bbox <- st_bbox(c(xmin = -3000000, xmax = 6000000, ymin = 3500000, ymax = 10000000), crs = mollweide_crs)
europe_polygon <- st_as_sfc(europe_bbox)
hfp2009<- crop(hfp2009, europe_polygon)
# change projection to that of medRegion
hfp2009<- terra::project(hfp2009, "+proj=longlat +datum=WGS84")
cat(crs(hfp2009))
# crop medregions from human footprint map
hfp2009<- mask(hfp2009, medRegions)
hfp2009<- crop(hfp2009, medRegions)

hfp_df <- as.data.frame(hfp2009, xy = TRUE)
colnames(hfp_df)[3] <- "hfp"  # Rename value column
hfp_df <- na.omit(hfp_df) 


# Step 5: Plot Density Map
EU <-ggplot() +
 geom_tile(data = bathy_df, aes(x = x, y = y, fill = elevation)) +
  scale_fill_gradientn(
    colors = c("lightblue3", "lightblue2", "lightblue1", "aliceblue"),
    name = "Depth (m)",       # Legend title (hidden in theme below)
    limits = c(-6000, 0),     # Adjust limits for ocean depths
    na.value = "aliceblue",   # Color for land areas
    guide = "none"            # Remove the legend for ocean depth
  ) +
  new_scale_fill() + 
  geom_sf(data = world, fill = NA, color = "black", size = 0.2, alpha=0.2) +
  # Add country borders
  geom_sf(data = medRegions, fill = "antiquewhite", color = "black", size = 0.2, alpha= 0.5) +
  new_scale_fill() +
  # Plot occurrences
  geom_raster(data = grid_df, aes(X, Y, fill = mean), alpha= 0.8) +
  scale_fill_viridis_c(option = "magma", trans= "log",na.value = "NA",
                       breaks = c(0,0.01, 0.1 ,1,10,100),
                       labels = c("0","0.01","0.1", "1", "10", "100"))+
  # Add country borders
  geom_sf(data = medRegions, fill = NA, color = "black", size = 0.2, alpha= 0.5)+
  # Define the map extent using the bounding box
  coord_sf(xlim = c(map_bbox[1], map_bbox[2]), 
           ylim = c(map_bbox[3], map_bbox[4]), 
           expand = FALSE) +
  theme_minimal()+
  # Customize the theme
  theme(
    panel.grid.major = element_line(color = gray(0.5), linetype = "dashed", size = 0.5),
    panel.background = element_rect(fill = "white", color = NA), # Keep a neutral background
    axis.title = element_blank(),  # Remove axis titles
    axis.text = element_text(size = 12, color = "black"),
    axis.ticks = element_line(color = "black"),
    plot.title = element_blank(),  # Remove map title
    plot.margin = margin(5, 5, 5, 5))+
  theme(
    legend.position = c(1, 0),  # Bottom-left corner
    legend.justification = c(1, 0),  # Anchor the legend box at its bottom-left
    legend.background = element_rect(fill = "aliceblue", color = "aliceblue"),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 10),
    legend.key.height = unit(0.6, "cm"),
    legend.key.width = unit(0.6, "cm")
  )+
  # Theme customization
  labs(fill = expression(bold("Alien plant\nprevalence [%]")),
       x = "Longitude",
       y = "Latitude")

EU

ggsave(EU, file= "../Images/Degree_invasion_EU.png", width=10, height=7)
```

